package com.ibaseit.utils;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.InvalidParameterException;
import java.security.KeyStore;
import java.security.SignatureException;
import java.text.MessageFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.bouncycastle.bcpg.ArmoredInputStream;
import org.bouncycastle.bcpg.ArmoredOutputStream;
import org.bouncycastle.bcpg.BCPGOutputStream;
import org.bouncycastle.openpgp.PGPCompressedData;
import org.bouncycastle.openpgp.PGPCompressedDataGenerator;
import org.bouncycastle.openpgp.PGPDataValidationException;
import org.bouncycastle.openpgp.PGPEncryptedDataGenerator;
import org.bouncycastle.openpgp.PGPEncryptedDataList;
import org.bouncycastle.openpgp.PGPException;
import org.bouncycastle.openpgp.PGPKeyPair;
import org.bouncycastle.openpgp.PGPLiteralData;
import org.bouncycastle.openpgp.PGPLiteralDataGenerator;
import org.bouncycastle.openpgp.PGPMarker;
import org.bouncycastle.openpgp.PGPObjectFactory;
import org.bouncycastle.openpgp.PGPOnePassSignature;
import org.bouncycastle.openpgp.PGPOnePassSignatureList;
import org.bouncycastle.openpgp.PGPPBEEncryptedData;
import org.bouncycastle.openpgp.PGPPrivateKey;
import org.bouncycastle.openpgp.PGPPublicKey;
import org.bouncycastle.openpgp.PGPPublicKeyEncryptedData;
import org.bouncycastle.openpgp.PGPPublicKeyRing;
import org.bouncycastle.openpgp.PGPSecretKey;
import org.bouncycastle.openpgp.PGPSecretKeyRing;
import org.bouncycastle.openpgp.PGPSecretKeyRingCollection;
import org.bouncycastle.openpgp.PGPSignature;
import org.bouncycastle.openpgp.PGPSignatureGenerator;
import org.bouncycastle.openpgp.PGPSignatureList;
import org.bouncycastle.openpgp.PGPSignatureSubpacketGenerator;
import org.bouncycastle.openpgp.PGPUtil;

public class PGPLib
  extends BaseLib
{
  private BCFactory a = new BCFactory(false);
  private String b = "SHA1";
  private String c = "CAST5";
  private String d = "ZIP";
  private boolean e = false;
  private boolean f = false;
  private static final Logger g = Logger.getLogger(PGPLib.class.getName());
  private String h = null;
  private char i = 'b';
  private Level j = Level.FINE;
  private boolean k = false;
  private boolean l = true;
  private boolean m = false;
  
  public PGPLib()
  {
    ArmoredOutputStream localArmoredOutputStream = new ArmoredOutputStream(new ByteArrayOutputStream());
  
  }
  
  public char getContentType()
  {
    return i;
  }
  
  public void setContentType(char paramChar)
  {
    if (('b' != paramChar) && ('t' != paramChar) && ('u' != paramChar))
    {
      a("Invalid content type {0}", String.valueOf(paramChar));
      a("Content type remains {0}", String.valueOf(i));
      return;
    }
    i = paramChar;
    a("Content type set to {0}", String.valueOf(i));
  }
  
  public Level getDebugLevel()
  {
    return j;
  }
  
  public void setDebuglevel(Level paramLevel)
  {
    j = paramLevel;
  }
  
  public boolean isUseExpiredKeys()
  {
    return e;
  }
  
  public void setUseExpiredKeys(boolean paramBoolean)
  {
    e = paramBoolean;
  }
  
  public boolean isUseRevokedKeys()
  {
    return f;
  }
  
  public void setUseRevokedKeys(boolean paramBoolean)
  {
    f = paramBoolean;
  }
  
  public void setHash(String paramString)
  {
    if (KeyStore.a(paramString) < 0) {
      throw new InvalidParameterException("Wrong value for parameter 'hash': " + paramString + ". Must be one of: SHA256, SHA384, SHA512, SHA224, SHA1, MD5, RIPEMD160, MD2");
    }
    b = paramString;
    a("Preferred hash set to {0}", b);
  }
  
  public String getCypher()
  {
    return c;
  }
  
  public String getAsciiCommentHeader()
  {
    return "";
  }
  
  public String getAsciiVersionHeader()
  {
    return "Version: " + h;
  }
  
  public void setAsciiVersionHeader(String paramString)
  {
    a("ASCII version header set to " + paramString);
    h = paramString;
  }
  
  private void a(OutputStream paramOutputStream)
  {
    if ((paramOutputStream instanceof ArmoredOutputStream)) {
      ((ArmoredOutputStream)paramOutputStream).setHeader("Version", h);
    }
  }
  
  public void setCypher(String paramString)
  {
    if (KeyStore.c(paramString) < 0) {
      throw new InvalidParameterException("Wrong value for parameter 'cypher': " + paramString + ". Must be one of: TRIPLE_DES, CAST5, BLOWFISH, AES_128, AES_192, AES_256, TWOFISH, DES, IDEA, SAFER");
    }
    c = paramString;
    a("Preferred cypher set to {0}", c);
  }
  
  public String getCompression()
  {
    return d;
  }
  
  public void setCompression(String paramString)
  {
    if (KeyStore.b(paramString) < 0) {
      throw new InvalidParameterException("Wrong value for parameter 'compression': " + paramString + ". Must be one of: ZLIB, ZIP, UNCOMPRESSED, BZIP2");
    }
    d = paramString;
    a("Preferred compression set to {0}", d);
  }
  
  public boolean detachedVerifyStream(InputStream paramInputStream1, InputStream paramInputStream2, InputStream paramInputStream3)
    throws PGPException, IOException
  {
    paramInputStream2 = PGPUtil.getDecoderStream(paramInputStream2);
    paramInputStream2 = new PGPObjectFactory2(paramInputStream2);
    try
    {
      paramInputStream2 = paramInputStream2.nextObject();
    }
    catch (IOException paramInputStream2)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", paramInputStream2);
    }
    if ((paramInputStream2 instanceof PGPSignatureList))
    {
      paramInputStream2 = (PGPSignatureList)paramInputStream2;
      PGPSignature localPGPSignature = null;
      PGPPublicKey localPGPPublicKey = null;
      for (int n = 0; n < paramInputStream2.size(); n++)
      {
        localPGPSignature = paramInputStream2.get(n);
        if ((localPGPPublicKey = readPublicVerificationKey(paramInputStream3, localPGPSignature.getKeyID())) != null) {
          break;
        }
      }
      if (localPGPPublicKey == null) {
        return false;
      }
      try
      {
        a.initVerify(localPGPSignature, localPGPPublicKey);
        localObject = new byte[1048576];
        while ((paramInputStream2 = paramInputStream1.read((byte[])localObject, 0, localObject.length)) > 0) {
          localPGPSignature.update((byte[])localObject, 0, paramInputStream2);
        }
        return localPGPSignature.verify();
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException)
      {
        Object localObject;
        throw IOUtil.newPGPException(localObject = localPGPException);
      }
    }
    throw new PGPException("Unknown message format: " + paramInputStream2.getClass().getName());
  }
  
  public boolean detachedVerifyStream(InputStream paramInputStream1, InputStream paramInputStream2, KeyStore paramKeyStore)
    throws PGPException, IOException
  {
    paramInputStream2 = PGPUtil.getDecoderStream(paramInputStream2);
    paramInputStream2 = new PGPObjectFactory2(paramInputStream2);
    try
    {
      paramInputStream2 = paramInputStream2.nextObject();
    }
    catch (IOException paramInputStream2)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", paramInputStream2);
    }
    if ((paramInputStream2 instanceof PGPSignatureList))
    {
      a("Detached signature found");
      paramInputStream2 = (PGPSignatureList)paramInputStream2;
      PGPSignature localPGPSignature = null;
      PGPPublicKey localPGPPublicKey = null;
      for (int n = 0; n < paramInputStream2.size(); n++)
      {
        localPGPSignature = paramInputStream2.get(n);
        a("Detached signature for key ID {0}", KeyPairInformation.keyId2Hex(localPGPSignature.getKeyID()));
        if ((localPGPPublicKey = readPublicVerificationKey(paramKeyStore, localPGPSignature.getKeyID())) != null) {
          break;
        }
      }
      if (localPGPPublicKey == null)
      {
        a("No matching public key found");
        return false;
      }
      try
      {
        a.initVerify(localPGPSignature, localPGPPublicKey);
        localObject = new byte[1048576];
        while ((paramInputStream2 = paramInputStream1.read((byte[])localObject, 0, localObject.length)) > 0) {
          localPGPSignature.update((byte[])localObject, 0, paramInputStream2);
        }
        if (localPGPSignature.verify())
        {
          a("Signature verified");
          return true;
        }
        a("Signature cannot be verified. Probably is tampered.");
        return false;
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException)
      {
        Object localObject;
        throw IOUtil.newPGPException(localObject = localPGPException);
      }
    }
    throw new PGPException("Unknown message format: " + paramInputStream2.getClass().getName());
  }
  
  public SignatureCheckResult detachedVerify(String paramString1, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    InputStream localInputStream3 = null;
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString1, "message");
      localInputStream2 = readFileOrAsciiString(paramString3, "publicKeyFile");
      localInputStream3 = readFileOrAsciiString(paramString2, "detachedSignature");
      paramString1 = detachedVerify(localInputStream1, localInputStream3, localInputStream2);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localInputStream3);
    }
  }
  
  public SignatureCheckResult detachedVerify(String paramString1, String paramString2, KeyStore paramKeyStore)
    throws PGPException, IOException
  {
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString1, "message");
      localInputStream2 = readFileOrAsciiString(paramString2, "detachedSignature");
      paramString1 = detachedVerify(localInputStream1, localInputStream2, paramKeyStore);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
    }
  }
  
  public SignatureCheckResult detachedVerify(InputStream paramInputStream1, InputStream paramInputStream2, InputStream paramInputStream3)
    throws PGPException, IOException
  {
    paramInputStream2 = PGPUtil.getDecoderStream(paramInputStream2);
    paramInputStream2 = new PGPObjectFactory2(paramInputStream2);
    try
    {
      paramInputStream2 = paramInputStream2.nextObject();
    }
    catch (IOException paramInputStream2)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", paramInputStream2);
    }
    if ((paramInputStream2 instanceof PGPSignatureList))
    {
      paramInputStream2 = (PGPSignatureList)paramInputStream2;
      PGPSignature localPGPSignature = null;
      PGPPublicKey localPGPPublicKey = null;
      for (int n = 0; n < paramInputStream2.size(); n++)
      {
        localPGPSignature = paramInputStream2.get(n);
        if ((localPGPPublicKey = readPublicVerificationKey(paramInputStream3, localPGPSignature.getKeyID())) != null) {
          break;
        }
      }
      if (localPGPPublicKey == null) {
        return SignatureCheckResult.PublicKeyNotMatching;
      }
      try
      {
        localPGPSignature.init(a.CreatePGPContentVerifierBuilderProvider(), localPGPPublicKey);
        localObject = new byte[1048576];
        while ((paramInputStream2 = paramInputStream1.read((byte[])localObject, 0, localObject.length)) > 0) {
          localPGPSignature.update((byte[])localObject, 0, paramInputStream2);
        }
        if (localPGPSignature.verify()) {
          return SignatureCheckResult.SignatureVerified;
        }
        return SignatureCheckResult.SignatureBroken;
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException)
      {
        Object localObject;
        throw IOUtil.newPGPException(localObject = localPGPException);
      }
    }
    throw new PGPException("Unknown message format: " + paramInputStream2.getClass().getName());
  }
  
  public SignatureCheckResult detachedVerify(InputStream paramInputStream1, InputStream paramInputStream2, KeyStore paramKeyStore)
    throws PGPException, IOException
  {
    paramInputStream2 = PGPUtil.getDecoderStream(paramInputStream2);
    paramInputStream2 = new PGPObjectFactory2(paramInputStream2);
    try
    {
      paramInputStream2 = paramInputStream2.nextObject();
    }
    catch (IOException paramInputStream2)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", paramInputStream2);
    }
    if ((paramInputStream2 instanceof PGPSignatureList))
    {
      a("Detached signature found");
      paramInputStream2 = (PGPSignatureList)paramInputStream2;
      PGPSignature localPGPSignature = null;
      PGPPublicKey localPGPPublicKey = null;
      for (int n = 0; n < paramInputStream2.size(); n++)
      {
        localPGPSignature = paramInputStream2.get(n);
        a("Detached signature for key ID {0}", KeyPairInformation.keyId2Hex(localPGPSignature.getKeyID()));
        if ((localPGPPublicKey = readPublicVerificationKey(paramKeyStore, localPGPSignature.getKeyID())) != null) {
          break;
        }
      }
      if (localPGPPublicKey == null)
      {
        a("No matching public key found");
        return SignatureCheckResult.PublicKeyNotMatching;
      }
      try
      {
        localPGPSignature.init(a.CreatePGPContentVerifierBuilderProvider(), localPGPPublicKey);
        localObject = new byte[1048576];
        while ((paramInputStream2 = paramInputStream1.read((byte[])localObject, 0, localObject.length)) > 0) {
          localPGPSignature.update((byte[])localObject, 0, paramInputStream2);
        }
        if (localPGPSignature.verify())
        {
          a("Signature verified");
          return SignatureCheckResult.SignatureVerified;
        }
        a("Signature verified failed. Probably it was tampered.");
        return SignatureCheckResult.SignatureBroken;
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException)
      {
        Object localObject;
        throw IOUtil.newPGPException(localObject = localPGPException);
      }
    }
    throw new PGPException("Unknown message format: " + paramInputStream2.getClass().getName());
  }
  
  public void detachedSignFile(String paramString1, String paramString2, String paramString3, String paramString4, boolean paramBoolean)
    throws PGPException, IOException
  {
    FileInputStream localFileInputStream = null;
    InputStream localInputStream = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localFileOutputStream = new FileOutputStream(paramString4);
      detachedSignStream(localFileInputStream, localInputStream, paramString3, localFileOutputStream, paramBoolean);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString4)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void detachedSignFile(String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2, String paramString3, boolean paramBoolean)
    throws PGPException, IOException
  {
    FileInputStream localFileInputStream = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localFileOutputStream = new FileOutputStream(paramString3);
      detachedSignStream(localFileInputStream, paramKeyStore, paramLong, paramString2, localFileOutputStream, paramBoolean);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString3)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void detachedSignFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String paramString4, boolean paramBoolean)
    throws PGPException, IOException
  {
    FileInputStream localFileInputStream = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localFileOutputStream = new FileOutputStream(paramString4);
      detachedSignStream(localFileInputStream, paramKeyStore, paramString2, paramString3, localFileOutputStream, paramBoolean);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString4)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void detachedSignStream(InputStream paramInputStream1, InputStream paramInputStream2, String paramString, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, IOException
  {
    paramInputStream2 = b(paramInputStream2);
    a(paramInputStream1, paramInputStream2, paramString, paramOutputStream, paramBoolean);
  }
  
  private void a(InputStream paramInputStream, PGPSecretKey paramPGPSecretKey, String paramString, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, IOException
  {
    if (paramBoolean)
    {
      paramOutputStream = paramOutputStream;
      paramOutputStream = new ArmoredOutputStream(paramOutputStream);
      a(paramOutputStream);
    }
    try
    {
      localObject = extractPrivateKey(paramPGPSecretKey, paramString);
      paramString = KeyStore.a(b);
      if (k) {
        paramString = 1;
      }
      a("Signing with private key {0}", KeyPairInformation.keyId2Hex(((PGPPrivateKey)localObject).getKeyID()));
      a("Signature has is {0}", KeyStore.b(paramString));
      paramString = a.CreatePGPV3SignatureGenerator(paramPGPSecretKey.getPublicKey().getAlgorithm(), paramString);
      a.initSign(paramString, 0, (PGPPrivateKey)localObject);
      paramPGPSecretKey = new BCPGOutputStream(paramOutputStream);
      localObject = new byte[1048576];
      int n;
      while ((n = paramInputStream.read((byte[])localObject, 0, localObject.length)) > 0) {
        paramString.update((byte[])localObject, 0, n);
      }
      IOUtil.closeStream(paramInputStream);
      if (paramString != null) {
        paramString.generate().encode(paramPGPSecretKey);
      }
      IOUtil.closeStream(paramPGPSecretKey);
      paramOutputStream.flush();
      if (paramBoolean) {
        IOUtil.closeStream(paramOutputStream);
      }
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      Object localObject;
      throw IOUtil.newPGPException(localObject = localPGPException);
    }
  }
  
  public void detachedSignStream(InputStream paramInputStream, KeyStore paramKeyStore, long paramLong, String paramString, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, IOException
  {
    paramKeyStore = c(paramKeyStore, paramLong);
    a(paramInputStream, paramKeyStore, paramString, paramOutputStream, paramBoolean);
  }
  
  public void detachedSignStream(InputStream paramInputStream, KeyStore paramKeyStore, String paramString1, String paramString2, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, NoPrivateKeyFoundException, IOException
  {
    long l1;
    if ((l1 = paramKeyStore.getKeyIdForUserId(paramString1)) < 0L) {
      throw new NoPrivateKeyFoundException("No private key pair was found with Id: " + paramString1);
    }
    paramKeyStore = c(paramKeyStore, paramKeyStore.getKeyIdForUserId(paramString1));
    a(paramInputStream, paramKeyStore, paramString2, paramOutputStream, paramBoolean);
  }
  
  public void clearSignFile(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException, WrongPasswordException
  {
    a("Clear text signing file {0}", paramString1);
    a("Output file is {0}", paramString5);
    BufferedInputStream localBufferedInputStream = null;
    FileInputStream localFileInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    int i1;
    if ((i1 = KeyStore.a(paramString4)) < 0) {
      throw new InvalidParameterException("Wrong value for parameter 'hashingAlgorithm': " + paramString4 + ". Must be one of: SHA256, SHA384, SHA512, SHA224, SHA1, MD5, RIPEMD160, MD2");
    }
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localFileInputStream = new FileInputStream(paramString2);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString5), 1048576);
      paramString1 = new PGPLib.1(this);
      paramString2 = b(localFileInputStream);
      paramString1.a(localBufferedInputStream, paramString2, paramString3, i1, localBufferedOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString5)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void clearSignFileVersion3(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException, WrongPasswordException
  {
    BufferedInputStream localBufferedInputStream = null;
    FileInputStream localFileInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    int i1;
    if ((i1 = KeyStore.a(paramString4)) < 0) {
      throw new InvalidParameterException("Wrong value for parameter 'hashingAlgorithm': " + paramString4 + ". Must be one of: SHA256, SHA384, SHA512, SHA224, SHA1, MD5, RIPEMD160, MD2");
    }
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localFileInputStream = new FileInputStream(paramString2);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString5), 1048576);
      paramString1 = new PGPLib.1(this);
      paramString2 = b(localFileInputStream);
      paramString1.b(localBufferedInputStream, paramString2, paramString3, i1, localBufferedOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString5)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public String clearSignString(String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException, WrongPasswordException
  {
    int n;
    if ((n = KeyStore.a(paramString4)) < 0) {
      throw new InvalidParameterException("Wrong value for parameter 'hashingAlgorithm': " + paramString4 + ". Must be one of: SHA256, SHA384, SHA512, SHA224, SHA1, MD5, RIPEMD160, MD2");
    }
    paramString4 = null;
    try
    {
      paramString4 = new FileInputStream(paramString2);
      paramString2 = new PGPLib.1(this);
      PGPSecretKey localPGPSecretKey = b(paramString4);
      paramString1 = paramString2.a(paramString1, localPGPSecretKey, paramString3, n);
      return paramString1;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(paramString4);
    }
  }
  
  public String clearSignStringVersion3(String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException, WrongPasswordException
  {
    int n;
    if ((n = KeyStore.a(paramString4)) < 0) {
      throw new InvalidParameterException("Wrong value for parameter 'hashingAlgorithm': " + paramString4 + ". Must be one of: SHA256, SHA384, SHA512, SHA224, SHA1, MD5, RIPEMD160, MD2");
    }
    paramString4 = null;
    try
    {
      paramString4 = new FileInputStream(paramString2);
      paramString2 = new PGPLib.1(this);
      PGPSecretKey localPGPSecretKey = b(paramString4);
      paramString1 = paramString2.b(paramString1, localPGPSecretKey, paramString3, n);
      return paramString1;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(paramString4);
    }
  }
  
  public void signFile(KeyStore paramKeyStore, String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, WrongPasswordException, IOException
  {
    signFile(paramKeyStore, paramString1, paramKeyStore.getKeyIdForKeyIdHex(paramString2), paramString3, paramString4);
  }
  
  public void signFile(KeyStore paramKeyStore, String paramString1, long paramLong, String paramString2, String paramString3)
    throws PGPException, WrongPasswordException, IOException
  {
    FileInputStream localFileInputStream = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      File localFile = new File(paramString1);
      localFileInputStream = new FileInputStream(paramString1);
      localFileOutputStream = new FileOutputStream(paramString3);
      paramKeyStore = b.getSecretKey(paramLong);
      a(localFileInputStream, localFile.getName(), paramKeyStore, paramString2, localFileOutputStream, false);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      n = 1;
      throw IOUtil.newPGPException(localPGPException);
    }
    catch (IOException localIOException)
    {
      n = 1;
      throw localIOException;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramString1 = new File(paramString3)).exists())) {
        paramString1.delete();
      }
    }
  }
  
  public void signFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String paramString4, boolean paramBoolean)
    throws PGPException, WrongPasswordException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localInputStream = b(paramKeyStore, paramString2);
      localFileOutputStream = new FileOutputStream(paramString4);
      paramKeyStore = b(localInputStream);
      paramString2 = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1));
      a(localBufferedInputStream, paramString2.getName(), paramKeyStore, paramString3, localFileOutputStream, paramBoolean);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramKeyStore)
    {
      n = 1;
      throw IOUtil.newPGPException(paramKeyStore);
    }
    catch (IOException paramKeyStore)
    {
      n = 1;
      throw paramKeyStore;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString4)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void signFile(String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2, String paramString3, boolean paramBoolean)
    throws PGPException,  IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localInputStream = e(paramKeyStore, paramLong);
      localFileOutputStream = new FileOutputStream(paramString3);
      paramKeyStore = b(localInputStream);
      paramLong = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1));
      a(localBufferedInputStream, paramLong.getName(), paramKeyStore, paramString2, localFileOutputStream, paramBoolean);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramKeyStore)
    {
      n = 1;
      throw IOUtil.newPGPException(paramKeyStore);
    }
    catch (IOException paramKeyStore)
    {
      n = 1;
      throw paramKeyStore;
    }
    finally
    {
      localInputStream.close();
      localBufferedInputStream.close();
     localFileOutputStream.close();
     
    }
  }
  
  public void signFile(String paramString1, String paramString2, String paramString3, String paramString4, boolean paramBoolean)
    throws IOException, PGPException, 
  {
    InputStream localInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString4), 1048576);
      signFile(paramString1, localInputStream, paramString3, localBufferedOutputStream, paramBoolean);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      localInputStream.close();;
    localBufferedOutputStream.close();;
     
    }
  }
  
  public void signFile(String paramString1, InputStream paramInputStream, String paramString2, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException
  {
    paramInputStream = paramInputStream;
    BufferedInputStream localBufferedInputStream = null;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1));
      a(localBufferedInputStream, new File(paramString1).getName(), paramInputStream, paramString2, paramOutputStream, paramBoolean);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      localBufferedInputStream.close();;
      paramOutputStream.close();;
    }
  }
  
  public void signStream(InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException, WrongPasswordException
  {
    paramInputStream2 = b(paramInputStream2);
    try
    {
      a(paramInputStream1, paramString1, paramInputStream2, paramString2, paramOutputStream, paramBoolean);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(paramInputStream1);
      IOUtil.closeStream(paramOutputStream);
    }
  }
  
  public void signStream(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException, 
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = b(paramKeyStore, paramString2);
      paramKeyStore = b(localInputStream);
      a(paramInputStream, paramString1, paramKeyStore, paramString3, paramOutputStream, paramBoolean);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(paramInputStream);
      IOUtil.closeStream(paramOutputStream);
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public void signStream(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException, WrongPasswordException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = e(paramKeyStore, paramLong);
      paramKeyStore = b(localInputStream);
      a(paramInputStream, paramString1, paramKeyStore, paramString2, paramOutputStream, paramBoolean);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(paramInputStream);
      IOUtil.closeStream(paramOutputStream);
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public void signFileVersion3(String paramString1, String paramString2, String paramString3, String paramString4, boolean paramBoolean)
    throws IOException, PGPException, WrongPasswordException
  {
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString4), 1048576);
      signStreamVersion3(localBufferedInputStream, new File(paramString1).getName(), localInputStream, paramString3, localBufferedOutputStream, paramBoolean);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString4)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void signStreamVersion3(InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException, WrongPasswordException
  {
    if (paramBoolean)
    {
      paramOutputStream = new ArmoredOutputStream(paramOutputStream);
      a(paramOutputStream);
    }
    paramInputStream2 = b(paramInputStream2);
    c(paramInputStream2.getPublicKey());
    e(paramInputStream2.getPublicKey());
    paramString2 = extractPrivateKey(paramInputStream2, paramString2);
    int n = g(paramInputStream2.getPublicKey());
    Object localObject;
    try
    {
      localObject = a.CreatePGPSignatureGenerator(paramInputStream2.getPublicKey().getAlgorithm(), n);
      a.initSign((PGPSignatureGenerator)localObject, 0, paramString2);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException1)
    {
      throw IOUtil.newPGPException(paramInputStream2 = localPGPException1);
    }
    if ((paramInputStream2 = paramInputStream2.getPublicKey().getUserIDs()).hasNext())
    {
      (paramString2 = new PGPSignatureSubpacketGenerator()).setSignerUserID(false, (String)paramInputStream2.next());
      ((PGPSignatureGenerator)localObject).setHashedSubpackets(paramString2.generate());
    }
    paramString2 = new PGPCompressedDataGenerator(2);
    paramInputStream2 = new BCPGOutputStream(paramString2.open(paramOutputStream));
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
    byte[] arrayOfByte = new byte[1048576];
    int i1;
    while ((i1 = paramInputStream1.read(arrayOfByte)) >= 0)
    {
      localDirectByteArrayOutputStream.write(arrayOfByte, 0, i1);
      ((PGPSignatureGenerator)localObject).update(arrayOfByte, 0, i1);
    }
    try
    {
      ((PGPSignatureGenerator)localObject).generate().encode(paramInputStream2);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException2)
    {
      throw IOUtil.newPGPException(localObject = localPGPException2);
    }
    a("Signing content with file name label {0}. (version 3, old style signature)", paramString1);
    (paramString1 = (localObject = new PGPLiteralDataGenerator()).open(paramInputStream2, getContentType(), paramString1, localDirectByteArrayOutputStream.size(), new Date())).write(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size());
    ((PGPLiteralDataGenerator)localObject).close();
    paramString2.close();
    IOUtil.closeStream(paramInputStream1);
    IOUtil.closeStream(localDirectByteArrayOutputStream);
    IOUtil.closeStream(paramString1);
    IOUtil.closeStream(paramInputStream2);
    paramOutputStream.flush();
    if (paramBoolean) {
      IOUtil.closeStream(paramOutputStream);
    }
  }
  
  public void signAndEncryptFile(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5, boolean paramBoolean)
    throws PGPException, WrongPasswordException, IOException
  {
    signAndEncryptFile(paramString1, paramString2, paramString3, paramString4, paramString5, paramBoolean, false);
  }
  
  public void signAndEncryptFile(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, WrongPasswordException, IOException
  {
    a("Signing file {0}", paramString1);
    InputStream localInputStream1 = null;
    BufferedOutputStream localBufferedOutputStream = null;
    InputStream localInputStream2 = null;
    BufferedInputStream localBufferedInputStream = null;
    int n = 0;
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString5), 1048576);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFile");
      signAndEncryptStream(localBufferedInputStream, new File(paramString1).getName(), localInputStream1, paramString3, localInputStream2, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localBufferedInputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localBufferedInputStream);
      if ((n != 0) && ((paramString2 = new File(paramString5)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void signAndEncryptFile(String paramString1, String paramString2, String paramString3, String[] paramArrayOfString, String paramString4, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, WrongPasswordException, IOException
  {
    a("Signing file {0}", paramString1);
    InputStream localInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    InputStream[] arrayOfInputStream = new InputStream[paramArrayOfString.length];
    BufferedInputStream localBufferedInputStream = null;
    int n = 0;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString4), 1048576);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      for (paramString2 = 0; paramString2 < paramArrayOfString.length; paramString2++) {
        arrayOfInputStream[paramString2] = readFileOrAsciiString(paramArrayOfString[paramString2], "publicKeyFiles: " + paramString2);
      }
      signAndEncryptStream(localBufferedInputStream, new File(paramString1).getName(), localInputStream, paramString3, arrayOfInputStream, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      for (paramString2 = 0; paramString2 < arrayOfInputStream.length; paramString2++) {
        IOUtil.closeStream(arrayOfInputStream[paramString2]);
      }
      IOUtil.closeStream(localBufferedInputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString2)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString2);
    }
    catch (IOException paramString2)
    {
      n = 1;
      throw paramString2;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      for (paramString2 = 0; paramString2 < arrayOfInputStream.length; paramString2++) {
        IOUtil.closeStream(arrayOfInputStream[paramString2]);
      }
      IOUtil.closeStream(localBufferedInputStream);
      if ((n != 0) && ((paramString2 = new File(paramString4)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void signAndEncryptFile(String paramString1, InputStream paramInputStream1, String paramString2, InputStream paramInputStream2, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException, WrongPasswordException
  {
    BufferedInputStream localBufferedInputStream = null;
    File localFile = new File(paramString1);
    a("Signing file {0}", paramString1);
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(localFile));
      signAndEncryptStream(localBufferedInputStream, localFile.getName(), paramInputStream1, paramString2, paramInputStream2, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(paramOutputStream);
    }
  }
  
  public void signAndEncryptStream(InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, InputStream paramInputStream3, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException, WrongPasswordException, NoPublicKeyFoundException, NoPrivateKeyFoundException
  {
    if (k)
    {
      new Date();
      a(paramInputStream1, paramString1, paramInputStream2, paramString2, new InputStream[] { paramInputStream3 }, paramOutputStream, paramBoolean1);
      return;
    }
    if (!(paramOutputStream instanceof BufferedOutputStream)) {
      paramOutputStream = new BufferedOutputStream(paramOutputStream, 1048576);
    }
    if (!paramInputStream3.markSupported()) {
      paramInputStream3 = new BufferedInputStream(paramInputStream3);
    }
    if (!paramInputStream2.markSupported()) {
      paramInputStream2 = new BufferedInputStream(paramInputStream2);
    }
    paramInputStream3.mark(1048576);
    paramInputStream2.mark(1048576);
    Object localObject1 = a(paramInputStream3);
    Object localObject2 = b(paramInputStream2);
    if (((PGPPublicKey)localObject1).getVersion() == 3)
    {
      paramInputStream3.reset();
      paramInputStream2.reset();
      a("Swithcing to version 3 signatures");
      signAndEncryptStreamVersion3(paramInputStream1, paramString1, paramInputStream2, paramString2, paramInputStream3, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    paramInputStream2 = null;
    try
    {
      if (paramBoolean1)
      {
        paramInputStream2 = paramOutputStream;
        paramOutputStream = new ArmoredOutputStream(paramInputStream2);
        a(paramOutputStream);
      }
      paramInputStream3 = f((PGPPublicKey)localObject1);
      a("Encrypting with cipher {0}", KeyStore.c(paramInputStream3));
      (paramInputStream3 = new PGPEncryptedDataGenerator(a.CreatePGPDataEncryptorBuilder(paramInputStream3, paramBoolean2, IOUtil.getSecureRandom()))).addMethod(a.CreatePublicKeyKeyEncryptionMethodGenerator((PGPPublicKey)localObject1));
      paramBoolean2 = paramInputStream3.open(paramOutputStream, new byte[65536]);
      paramString2 = extractPrivateKey((PGPSecretKey)localObject2, paramString2);
      int i1 = g(((PGPSecretKey)localObject2).getPublicKey());
      a("Signing with hash {0}", KeyStore.b(i1));
      PGPSignatureGenerator localPGPSignatureGenerator = a.CreatePGPSignatureGenerator(((PGPSecretKey)localObject2).getPublicKey().getAlgorithm(), i1);
      a.initSign(localPGPSignatureGenerator, 0, paramString2);
      paramString2 = ((PGPSecretKey)localObject2).getPublicKey().getUserIDs();
      while (paramString2.hasNext())
      {
        localObject2 = (String)paramString2.next();
        localObject3 = new PGPSignatureSubpacketGenerator();
        a("Signing with User ID {0}", (String)localObject2);
        ((PGPSignatureSubpacketGenerator)localObject3).setSignerUserID(false, (String)localObject2);
        localPGPSignatureGenerator.setHashedSubpackets(((PGPSignatureSubpacketGenerator)localObject3).generate());
      }
      int n = h((PGPPublicKey)localObject1);
      Object localObject3 = new PGPCompressedDataGenerator(n);
      paramString2 = null;
      localObject1 = new PGPLiteralDataGenerator();
      OutputStream localOutputStream;
      if (n == 0)
      {
        a("No compression.");
        localPGPSignatureGenerator.generateOnePassVersion(false).encode(paramBoolean2);
        localOutputStream = ((PGPLiteralDataGenerator)localObject1).open(paramBoolean2, 'b', paramString1, new Date(), new byte[1048576]);
      }
      else
      {
        a("Compression is {0}", KeyStore.a(localOutputStream));
        paramString2 = ((PGPCompressedDataGenerator)localObject3).open(paramBoolean2, new byte[65536]);
        localPGPSignatureGenerator.generateOnePassVersion(false).encode(paramString2);
        localOutputStream = ((PGPLiteralDataGenerator)localObject1).open(paramString2, 'b', paramString1, new Date(), new byte[1048576]);
      }
      a("Signing stream content with internal file name label: {0}", paramString1);
      paramString1 = new byte[65536];
      int i2;
      while ((i2 = paramInputStream1.read(paramString1, 0, paramString1.length)) != -1)
      {
        localOutputStream.write(paramString1, 0, i2);
        localPGPSignatureGenerator.update(paramString1, 0, i2);
      }
      IOUtil.closeStream(localOutputStream);
      ((PGPLiteralDataGenerator)localObject1).close();
      if (paramString2 == null) {
        localPGPSignatureGenerator.generate().encode(paramBoolean2);
      } else {
        localPGPSignatureGenerator.generate().encode(paramString2);
      }
      IOUtil.closeStream(paramString2);
      ((PGPCompressedDataGenerator)localObject3).close();
      IOUtil.closeStream(paramBoolean2);
      paramInputStream3.close();
      IOUtil.closeStream(paramInputStream1);
      if (paramBoolean1) {
        paramOutputStream.close();
      }
      if (paramBoolean1)
      {
        IOUtil.closeStream(paramOutputStream);
        paramInputStream2.flush();
        return;
      }
      paramOutputStream.flush();
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      if (paramBoolean1)
      {
        IOUtil.closeStream(paramOutputStream);
        paramInputStream2.flush();
      }
      else
      {
        paramOutputStream.flush();
      }
    }
  }
  
  public void signAndEncryptStream(InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, InputStream[] paramArrayOfInputStream, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException, WrongPasswordException, NoPublicKeyFoundException, NoPrivateKeyFoundException
  {
    if (k)
    {
      new Date();
      a(paramInputStream1, paramString1, paramInputStream2, paramString2, paramArrayOfInputStream, paramOutputStream, paramBoolean1);
      return;
    }
    try
    {
      if (paramBoolean1)
      {
        paramOutputStream = new ArmoredOutputStream(paramOutputStream);
        a(paramOutputStream);
      }
      int n = KeyStore.c(c);
      a("Encrypting with cipher {0}", KeyStore.c(n));
      paramBoolean2 = new PGPEncryptedDataGenerator(a.CreatePGPDataEncryptorBuilder(n, paramBoolean2, IOUtil.getSecureRandom()));
      for (n = 0; n < paramArrayOfInputStream.length; n++)
      {
        localObject2 = a(paramArrayOfInputStream[n]);
        a("Encrypting with public key {0}", KeyPairInformation.keyId2Hex(((PGPPublicKey)localObject2).getKeyID()));
        paramBoolean2.addMethod(a.CreatePublicKeyKeyEncryptionMethodGenerator((PGPPublicKey)localObject2));
      }
      localObject1 = paramBoolean2.open(paramOutputStream, new byte[65536]);
      paramInputStream2 = extractPrivateKey(localObject2 = b(paramInputStream2), paramString2);
      paramString2 = g(((PGPSecretKey)localObject2).getPublicKey());
      a("Signing with hash {0}", KeyStore.b(paramString2));
      paramString2 = a.CreatePGPSignatureGenerator(((PGPSecretKey)localObject2).getPublicKey().getAlgorithm(), paramString2);
      a.initSign(paramString2, 0, paramInputStream2);
      paramInputStream2 = ((PGPSecretKey)localObject2).getPublicKey().getUserIDs();
      while (paramInputStream2.hasNext())
      {
        paramArrayOfInputStream = (String)paramInputStream2.next();
        (localObject2 = new PGPSignatureSubpacketGenerator()).setSignerUserID(false, paramArrayOfInputStream);
        paramString2.setHashedSubpackets(((PGPSignatureSubpacketGenerator)localObject2).generate());
      }
      paramArrayOfInputStream = KeyStore.b(d);
      Object localObject2 = new PGPCompressedDataGenerator(paramArrayOfInputStream);
      paramInputStream2 = null;
      PGPLiteralDataGenerator localPGPLiteralDataGenerator = new PGPLiteralDataGenerator();
      if (paramArrayOfInputStream == 0)
      {
        a("No Compression.");
        paramString2.generateOnePassVersion(false).encode((OutputStream)localObject1);
        paramArrayOfInputStream = localPGPLiteralDataGenerator.open((OutputStream)localObject1, 'b', paramString1, new Date(), new byte[1048576]);
      }
      else
      {
        a("Compression is {0}", KeyStore.a(paramArrayOfInputStream));
        paramInputStream2 = ((PGPCompressedDataGenerator)localObject2).open((OutputStream)localObject1, new byte[65536]);
        paramString2.generateOnePassVersion(false).encode(paramInputStream2);
        paramArrayOfInputStream = localPGPLiteralDataGenerator.open(paramInputStream2, 'b', paramString1, new Date(), new byte[1048576]);
      }
      a("Signing stream content with internal file name label: {0}", paramString1);
      paramString1 = new byte[65536];
      int i1;
      while ((i1 = paramInputStream1.read(paramString1, 0, paramString1.length)) != -1)
      {
        paramArrayOfInputStream.write(paramString1, 0, i1);
        paramString2.update(paramString1, 0, i1);
      }
      IOUtil.closeStream(paramArrayOfInputStream);
      localPGPLiteralDataGenerator.close();
      if (paramInputStream2 == null) {
        paramString2.generate().encode((OutputStream)localObject1);
      } else {
        paramString2.generate().encode(paramInputStream2);
      }
      IOUtil.closeStream(paramInputStream2);
      ((PGPCompressedDataGenerator)localObject2).close();
      IOUtil.closeStream((OutputStream)localObject1);
      paramBoolean2.close();
      IOUtil.closeStream(paramInputStream1);
      if (paramBoolean1) {
        paramOutputStream.close();
      }
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      Object localObject1;
      throw IOUtil.newPGPException(localObject1 = localPGPException);
    }
  }
  
  public void signAndEncryptFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String paramString4, String paramString5, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException
  {
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    a("Signing and encrypting file {0}", paramString1);
    a("Output file is {0}", new File(paramString5).getAbsolutePath());
    try
    {
      localInputStream1 = a(paramKeyStore, paramString4);
      localInputStream2 = b(paramKeyStore, paramString2);
      paramKeyStore = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(new File(paramString5)), 1048576);
      signAndEncryptStream(localBufferedInputStream, paramKeyStore.getName(), localInputStream2, paramString3, localInputStream1, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localInputStream1);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramKeyStore)
    {
      n = 1;
      throw IOUtil.newPGPException(paramKeyStore);
    }
    catch (IOException paramKeyStore)
    {
      n = 1;
      throw paramKeyStore;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localInputStream1);
      if ((n != 0) && ((paramKeyStore = new File(paramString5)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void signAndEncryptFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String[] paramArrayOfString, String paramString4, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException
  {
    InputStream[] arrayOfInputStream = new InputStream[paramArrayOfString.length];
    InputStream localInputStream = null;
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    a("Signing and encrypting file {0}", paramString1);
    a("Output file is {0}", new File(paramString4).getAbsolutePath());
    try
    {
      for (int i1 = 0; i1 < arrayOfInputStream.length; i1++) {
        arrayOfInputStream[i1] = a(paramKeyStore, paramArrayOfString[i1]);
      }
      localInputStream = b(paramKeyStore, paramString2);
      File localFile = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString4), 1048576);
      signAndEncryptStream(localBufferedInputStream, localFile.getName(), localInputStream, paramString3, arrayOfInputStream, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream);
      for (int i2 = 0; i2 < arrayOfInputStream.length; i2++) {
        IOUtil.closeStream(arrayOfInputStream[i2]);
      }
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      n = 1;
      throw IOUtil.newPGPException(localPGPException);
    }
    catch (IOException localIOException)
    {
      n = 1;
      throw localIOException;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream);
      for (paramKeyStore = 0; paramKeyStore < arrayOfInputStream.length; paramKeyStore++) {
        IOUtil.closeStream(arrayOfInputStream[paramKeyStore]);
      }
      if ((n != 0) && ((paramKeyStore = new File(paramString4)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void signAndEncryptFile(String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2, long[] paramArrayOfLong, String paramString3, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException
  {
    InputStream[] arrayOfInputStream = new InputStream[paramArrayOfLong.length];
    InputStream localInputStream = null;
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    a("Signing and encrypting file {0}", paramString1);
    a("Output file is {0}", new File(paramString3).getAbsolutePath());
    try
    {
      for (int i1 = 0; i1 < arrayOfInputStream.length; i1++) {
        arrayOfInputStream[i1] = d(paramKeyStore, paramArrayOfLong[i1]);
      }
      localInputStream = e(paramKeyStore, paramLong);
      File localFile = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString3), 1048576);
      signAndEncryptStream(localBufferedInputStream, localFile.getName(), localInputStream, paramString2, arrayOfInputStream, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream);
      for (int i2 = 0; i2 < arrayOfInputStream.length; i2++) {
        IOUtil.closeStream(arrayOfInputStream[i2]);
      }
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      n = 1;
      throw IOUtil.newPGPException(localPGPException);
    }
    catch (IOException localIOException)
    {
      n = 1;
      throw localIOException;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream);
      for (paramKeyStore = 0; paramKeyStore < arrayOfInputStream.length; paramKeyStore++) {
        IOUtil.closeStream(arrayOfInputStream[paramKeyStore]);
      }
      if ((n != 0) && ((paramKeyStore = new File(paramString3)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void signAndEncryptFile(String paramString1, KeyStore paramKeyStore, long paramLong1, String paramString2, long paramLong2, String paramString3, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException
  {
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    a("Signing and encrypting file {0}", paramString1);
    a("Output file is {0}", new File(paramString3).getAbsolutePath());
    int n = 0;
    try
    {
      localInputStream1 = d(paramKeyStore, paramLong2);
      localInputStream2 = e(paramKeyStore, paramLong1);
      paramKeyStore = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString3), 1048576);
      signAndEncryptStream(localBufferedInputStream, paramKeyStore.getName(), localInputStream2, paramString2, localInputStream1, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localInputStream1);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramKeyStore)
    {
      n = 1;
      throw IOUtil.newPGPException(paramKeyStore);
    }
    catch (IOException paramKeyStore)
    {
      n = 1;
      throw paramKeyStore;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localInputStream1);
      if ((n != 0) && ((paramKeyStore = new File(paramString3)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void signAndEncryptStream(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String paramString4, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException
  {
    try
    {
      paramString4 = a(paramKeyStore, paramString4);
      paramKeyStore = b(paramKeyStore, paramString2);
      signAndEncryptStream(paramInputStream, paramString1, paramKeyStore, paramString3, paramString4, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(paramString4 = localPGPException);
    }
  }
  
  public void signAndEncryptStream(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String[] paramArrayOfString, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException
  {
    InputStream[] arrayOfInputStream = new InputStream[paramArrayOfString.length];
    try
    {
      paramString2 = b(paramKeyStore, paramString2);
      for (int n = 0; n < paramArrayOfString.length; n++) {
        arrayOfInputStream[n] = a(paramKeyStore, paramArrayOfString[n]);
      }
      signAndEncryptStream(paramInputStream, paramString1, paramString2, paramString3, arrayOfInputStream, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(paramString2 = localPGPException);
    }
  }
  
  public void signAndEncryptStream(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, long[] paramArrayOfLong, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException
  {
    InputStream[] arrayOfInputStream = new InputStream[paramArrayOfLong.length];
    try
    {
      paramString2 = b(paramKeyStore, paramString2);
      for (int n = 0; n < paramArrayOfLong.length; n++) {
        arrayOfInputStream[n] = d(paramKeyStore, paramArrayOfLong[n]);
      }
      signAndEncryptStream(paramInputStream, paramString1, paramString2, paramString3, arrayOfInputStream, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(paramString2 = localPGPException);
    }
  }
  
  public void signAndEncryptFileVersion3(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5, boolean paramBoolean)
    throws PGPException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    a("Signing and encrypting file {0}", paramString1);
    a("Output file is {0}", new File(paramString5).getAbsolutePath());
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString5), 1048576);
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFile");
      signAndEncryptStreamVersion3(localBufferedInputStream, new File(paramString1).getName(), localInputStream1, paramString3, localInputStream2, localBufferedOutputStream, paramBoolean, false);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      if ((n != 0) && ((paramString2 = new File(paramString5)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void signAndEncryptFileVersion3(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    BufferedOutputStream localBufferedOutputStream = null;
    a("Signing and encrypting file {0}", paramString1);
    a("Output file is {0}", new File(paramString5).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString5), 1048576);
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFile");
      signAndEncryptStreamVersion3(localBufferedInputStream, new File(paramString1).getName(), localInputStream1, paramString3, localInputStream2, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream2);
      if ((n != 0) && ((paramString2 = new File(paramString5)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void signAndEncryptStreamVersion3(InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, InputStream paramInputStream3, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException, WrongPasswordException
  {
    signAndEncryptStreamVersion3(paramInputStream1, paramString1, paramInputStream2, paramString2, paramInputStream3, paramOutputStream, paramBoolean);
  }
  
  public void signAndEncryptStreamVersion3(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String paramString4, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException, WrongPasswordException
  {
    paramString4 = a(paramKeyStore, paramString4);
    paramKeyStore = b(paramKeyStore, paramString2);
    signAndEncryptStreamVersion3(paramInputStream, paramString1, paramKeyStore, paramString3, paramString4, paramOutputStream, paramBoolean);
  }
  
  public void signAndEncryptStreamVersion3(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, long paramLong1, String paramString2, long paramLong2, OutputStream paramOutputStream, boolean paramBoolean)
    throws IOException, PGPException, WrongPasswordException
  {
    paramLong2 = d(paramKeyStore, paramLong2);
    paramKeyStore = e(paramKeyStore, paramLong1);
    signAndEncryptStreamVersion3(paramInputStream, paramString1, paramKeyStore, paramString2, paramLong2, paramOutputStream, paramBoolean);
  }
  
  public void signAndEncryptStreamVersion3(InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, InputStream paramInputStream3, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws IOException, PGPException, WrongPasswordException
  {
    if (!(paramOutputStream instanceof BufferedOutputStream)) {
      paramOutputStream = new BufferedOutputStream(paramOutputStream, 262144);
    }
    paramInputStream3 = a(paramInputStream3);
    paramInputStream2 = b(paramInputStream2);
    if (paramBoolean1)
    {
      paramOutputStream = new ArmoredOutputStream(paramOutputStream);
      a(paramOutputStream);
    }
    int n = f(paramInputStream3);
    a("Encrypting with cypher {0}", KeyStore.c(n));
    paramBoolean2 = new PGPEncryptedDataGenerator(a.CreatePGPDataEncryptorBuilder(n, paramBoolean2, IOUtil.getSecureRandom()));
    OutputStream localOutputStream;
    try
    {
      paramBoolean2.addMethod(a.CreatePublicKeyKeyEncryptionMethodGenerator(paramInputStream3));
      localOutputStream = paramBoolean2.open(paramOutputStream, new byte[65536]);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException1)
    {
      throw IOUtil.newPGPException(paramInputStream3 = localPGPException1);
    }
    paramInputStream3 = h(paramInputStream3);
    PGPCompressedDataGenerator localPGPCompressedDataGenerator = new PGPCompressedDataGenerator(paramInputStream3);
    paramString2 = extractPrivateKey(paramInputStream2, paramString2);
    int i1 = g(paramInputStream2.getPublicKey());
    a("Signing with hash {0}", KeyStore.c(i1));
    PGPSignatureGenerator localPGPSignatureGenerator = a.CreatePGPSignatureGenerator(paramInputStream2.getPublicKey().getAlgorithm(), i1);
    a.initSign(localPGPSignatureGenerator, 0, paramString2);
    if ((paramInputStream2 = paramInputStream2.getPublicKey().getUserIDs()).hasNext())
    {
      paramInputStream2 = (String)paramInputStream2.next();
      (paramString2 = new PGPSignatureSubpacketGenerator()).setSignerUserID(false, paramInputStream2);
      localPGPSignatureGenerator.setHashedSubpackets(paramString2.generate());
    }
    paramInputStream2 = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(262144);
    PGPLiteralDataGenerator localPGPLiteralDataGenerator = new PGPLiteralDataGenerator();
    try
    {
      byte[] arrayOfByte = new byte[262144];
      while ((paramString2 = paramInputStream1.read(arrayOfByte)) >= 0)
      {
        localDirectByteArrayOutputStream.write(arrayOfByte, 0, paramString2);
        localPGPSignatureGenerator.update(arrayOfByte, 0, paramString2);
      }
      a("Signing data with OpenPGP version 3 signature; internal file name {0}", paramString1);
      if (paramInputStream3 == 0)
      {
        a("No Compression.");
        localPGPSignatureGenerator.generate().encode(localOutputStream);
        paramString2 = localPGPLiteralDataGenerator.open(localOutputStream, 'b', paramString1, new Date(), new byte[65536]);
      }
      else
      {
        a("Compression is {0}", KeyStore.a(paramInputStream3));
        paramInputStream2 = localPGPCompressedDataGenerator.open(localOutputStream, new byte[65536]);
        localPGPSignatureGenerator.generate().encode(paramInputStream2);
        paramString2 = localPGPLiteralDataGenerator.open(paramInputStream2, 'b', paramString1, new Date(), new byte[65536]);
      }
      paramString2.write(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size());
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException2)
    {
      throw IOUtil.newPGPException(paramString2 = localPGPException2);
    }
    IOUtil.closeStream(paramString2);
    localPGPLiteralDataGenerator.close();
    IOUtil.closeStream(paramInputStream2);
    localPGPCompressedDataGenerator.close();
    IOUtil.closeStream(localOutputStream);
    paramBoolean2.close();
    IOUtil.closeStream(localDirectByteArrayOutputStream);
    IOUtil.closeStream(paramInputStream1);
    paramOutputStream.flush();
    if (paramBoolean1) {
      IOUtil.closeStream(paramOutputStream);
    }
  }
  
  public String signAndEncryptString(String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException
  {
    return signAndEncryptString(paramString1, paramString2, paramString3, paramString4, "UTF-8");
  }
  
  public String signAndEncryptStringVersion3(String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException
  {
    return signAndEncryptStringVersion3(paramString1, paramString2, paramString3, paramString4, "UTF-8");
  }
  
  public String signAndEncryptString(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFileName");
      paramString2 = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString5));
      signAndEncryptStream(localByteArrayInputStream, "message.txt", localInputStream1, paramString3, localInputStream2, paramString2, true, false);
      paramString1 = new String(paramString2.getArray(), 0, paramString2.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
    }
  }
  
  public String signAndEncryptStringVersion3(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFileName");
      paramString2 = new DirectByteArrayOutputStream(262144);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString5));
      signAndEncryptStreamVersion3(localByteArrayInputStream, "message.txt", localInputStream1, paramString3, localInputStream2, paramString2, true, false);
      paramString1 = new String(paramString2.getArray(), 0, paramString2.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
    }
  }
  
  public String decryptString(String paramString1, String paramString2, String paramString3)
    throws IOException, PGPException
  {
    return decryptString(paramString1, paramString2, paramString3, "UTF-8");
  }
  
  public String decryptString(String paramString1, String paramString2, String paramString3, String paramString4)
    throws IOException, PGPException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFileName");
      paramString1 = decryptString(paramString1, localInputStream, paramString3, paramString4);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String decryptString(String paramString1, InputStream paramInputStream, String paramString2)
    throws IOException, PGPException
  {
    return decryptString(paramString1, paramInputStream, paramString2, "UTF-8");
  }
  
  public String decryptString(String paramString1, KeyStore paramKeyStore, String paramString2)
    throws IOException, PGPException
  {
    return decryptString(paramString1, paramKeyStore, paramString2, "UTF-8");
  }
  
  public String decryptString(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws IOException, PGPException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes("ASCII"));
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      decryptStream(localByteArrayInputStream, paramKeyStore, paramString2, localDirectByteArrayOutputStream);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString3);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  public String decryptString(String paramString1, InputStream paramInputStream, String paramString2, String paramString3)
    throws IOException, PGPException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes("ASCII"));
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      decryptStream(localByteArrayInputStream, paramInputStream, paramString2, localDirectByteArrayOutputStream);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString3);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  public String decryptStream(InputStream paramInputStream1, InputStream paramInputStream2, String paramString, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1);
    paramInputStream1 = new PGPObjectFactory2(paramInputStream1);
    Object localObject;    try
    {
      localObject = paramInputStream1.nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((localObject instanceof PGPMarker))
    {
      a("Skipping PGP marker.");
      localObject = paramInputStream1.nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((localObject instanceof PGPEncryptedDataList))
    {
      paramInputStream1 = (PGPEncryptedDataList)localObject;
      paramInputStream1 = a(paramInputStream1, false, localA, null, paramInputStream2, paramString, null, paramOutputStream);
    }
    else if ((localObject instanceof PGPCompressedData))
    {
      paramInputStream1 = a((PGPCompressedData)localObject, false, localA, null, null, paramOutputStream);
    }
    else if ((localObject instanceof PGPOnePassSignatureList))
    {
      paramInputStream1 = a((PGPOnePassSignatureList)localObject, paramInputStream1, null, null, paramOutputStream, localA);
    }
    else if ((localObject instanceof PGPSignatureList))
    {
      paramInputStream1 = a((PGPSignatureList)localObject, paramInputStream1, null, null, paramOutputStream, localA);
    }
    else if ((localObject instanceof PGPLiteralData))
    {
      paramInputStream1 = a((PGPLiteralData)localObject, null, paramOutputStream);
    }
    else
    {
      throw new NonPGPDataException("Unknown message format: " + localObject);
    }
    return paramInputStream1;
  }
  
  public String[] decryptStreamTo(InputStream paramInputStream1, InputStream paramInputStream2, String paramString1, String paramString2)
    throws PGPException, IOException
  {
    return a(paramInputStream1, paramInputStream2, paramString1, paramString2, null);
  }
  
  private String[] a(InputStream paramInputStream1, InputStream paramInputStream2, String paramString1, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    a("Decrypting stream to folder {0}", new File(paramString2).getAbsolutePath());
    paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1);
    paramInputStream1 = new PGPObjectFactory2(paramInputStream1);
    Object localObject;
    try
    {
      localObject = paramInputStream1.nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((localObject instanceof PGPMarker))
    {
      a("Skipping PGP marker.");
      localObject = paramInputStream1.nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((localObject instanceof PGPEncryptedDataList))
    {
      paramInputStream1 = (PGPEncryptedDataList)localObject;
      paramInputStream1 = a(paramInputStream1, false, localA, null, paramInputStream2, paramString1, null, paramString2, paramString3);
    }
    else if ((localObject instanceof PGPCompressedData))
    {
      paramInputStream1 = a((PGPCompressedData)localObject, false, localA, null, null, paramString2, paramString3);
    }
    else if ((localObject instanceof PGPOnePassSignatureList))
    {
      paramInputStream1 = a((PGPOnePassSignatureList)localObject, paramInputStream1, null, null, paramString2, paramString3, localA);
    }
    else if ((localObject instanceof PGPSignatureList))
    {
      paramInputStream1 = a((PGPSignatureList)localObject, paramInputStream1, null, null, paramString2, paramString3, localA);
    }
    else if ((localObject instanceof PGPLiteralData))
    {
      paramInputStream1 = a((PGPLiteralData)localObject, null, paramString2, paramString3);
    }
    else
    {
      throw new NonPGPDataException("Unknown message format: " + localObject);
    }
    return paramInputStream1;
  }
  
  public String[] decryptStreamTo(InputStream paramInputStream, KeyStore paramKeyStore, String paramString1, String paramString2)
    throws PGPException, IOException
  {
    return a(paramInputStream, paramKeyStore, paramString1, paramString2, null);
  }
  
  private String[] a(InputStream paramInputStream, KeyStore paramKeyStore, String paramString1, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    a("Decrypting stream to folder {0}", new File(paramString2).getAbsolutePath());
    paramInputStream = PGPUtil.getDecoderStream(paramInputStream);
    paramInputStream = new PGPObjectFactory2(paramInputStream);
    Object localObject;
    try
    {
      localObject = paramInputStream.nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((localObject instanceof PGPMarker))
    {
      a("Skipping PGP marker.");
      localObject = paramInputStream.nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((localObject instanceof PGPEncryptedDataList))
    {
      paramInputStream = (PGPEncryptedDataList)localObject;
      paramInputStream = a(paramInputStream, false, localA, paramKeyStore, null, paramString1, null, paramString2, paramString3);
    }
    else if ((localObject instanceof PGPCompressedData))
    {
      paramInputStream = a((PGPCompressedData)localObject, false, localA, null, null, paramString2, paramString3);
    }
    else if ((localObject instanceof PGPOnePassSignatureList))
    {
      paramInputStream = a((PGPOnePassSignatureList)localObject, paramInputStream, null, null, paramString2, paramString3, localA);
    }
    else if ((localObject instanceof PGPSignatureList))
    {
      paramInputStream = a((PGPSignatureList)localObject, paramInputStream, null, null, paramString2, paramString3, localA);
    }
    else if ((localObject instanceof PGPLiteralData))
    {
      paramInputStream = a((PGPLiteralData)localObject, null, paramString2, paramString3);
    }
    else
    {
      throw new NonPGPDataException("Unknown message format: " + localObject);
    }
    return paramInputStream;
  }
  
  public String decryptStream(InputStream paramInputStream, KeyStore paramKeyStore, String paramString, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    paramInputStream = PGPUtil.getDecoderStream(paramInputStream);
    paramInputStream = new PGPObjectFactory2(paramInputStream);
    Object localObject;
    try
    {
      localObject = paramInputStream.nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((localObject instanceof PGPMarker))
    {
      a("Skipping PGP marker.");
      localObject = paramInputStream.nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((localObject instanceof PGPEncryptedDataList))
    {
      paramInputStream = (PGPEncryptedDataList)localObject;
      paramInputStream = a(paramInputStream, false, localA, paramKeyStore, null, paramString, null, paramOutputStream);
    }
    else if ((localObject instanceof PGPCompressedData))
    {
      paramInputStream = a((PGPCompressedData)localObject, false, localA, null, null, paramOutputStream);
    }
    else if ((localObject instanceof PGPLiteralData))
    {
      paramInputStream = a((PGPLiteralData)localObject, null, paramOutputStream);
    }
    else if ((localObject instanceof PGPOnePassSignatureList))
    {
      paramInputStream = a((PGPOnePassSignatureList)localObject, paramInputStream, null, null, paramOutputStream, localA);
    }
    else if ((localObject instanceof PGPSignatureList))
    {
      paramInputStream = a((PGPSignatureList)localObject, paramInputStream, null, null, paramOutputStream, localA);
    }
    else
    {
      throw new NonPGPDataException("Unknown message format: " + localObject);
    }
    return paramInputStream;
  }
  
  public String decryptFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    FileInputStream localFileInputStream = null;
    FileOutputStream localFileOutputStream = null;
    a("Decrypting file {0}", paramString1);
    a("Decrypting to {0}", new File(paramString3).getAbsolutePath());
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localFileOutputStream = new FileOutputStream(paramString3);
      paramString1 = decryptStream(localFileInputStream, paramKeyStore, paramString2, localFileOutputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return paramString1;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString3)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public String decryptFile(String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException
  {
    a("Decrypting file {0}", paramString1);
    InputStream localInputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFileName");
      paramString1 = decryptFile(paramString1, localInputStream, paramString3, paramString4);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String decryptFilePBE(String paramString1, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    a("Decrypting password encrypted file {0}", paramString1);
    a("Decrypting to {0}", new File(paramString3).getAbsolutePath());
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1));
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString3));
      paramString1 = decryptStreamPBE(localBufferedInputStream, paramString2, localBufferedOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return paramString1;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString3)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public String decryptStringPBE(String paramString1, String paramString2)
    throws IOException, PGPException
  {
    return decryptStringPBE(paramString1, paramString2, "UTF-8");
  }
  
  public String decryptStringPBE(String paramString1, String paramString2, String paramString3)
    throws IOException, PGPException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes("ASCII"));
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      decryptStreamPBE(localByteArrayInputStream, paramString2, localDirectByteArrayOutputStream);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString3);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  public String decryptStreamPBE(InputStream paramInputStream, String paramString, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    paramInputStream = PGPUtil.getDecoderStream(paramInputStream);
    paramInputStream = new PGPObjectFactory2(paramInputStream);
    Object localObject;
    try
    {
      localObject = paramInputStream.nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((localObject instanceof PGPMarker)) {
      localObject = paramInputStream.nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((localObject instanceof PGPEncryptedDataList))
    {
      paramInputStream = (PGPEncryptedDataList)localObject;
      paramInputStream = a(paramInputStream, false, localA, paramString, null, null, paramOutputStream);
    }
    else if ((localObject instanceof PGPCompressedData))
    {
      paramInputStream = a((PGPCompressedData)localObject, false, localA, null, null, paramOutputStream);
    }
    else if ((localObject instanceof PGPOnePassSignatureList))
    {
      paramInputStream = a((PGPOnePassSignatureList)localObject, paramInputStream, null, null, paramOutputStream, localA);
    }
    else if ((localObject instanceof PGPSignatureList))
    {
      paramInputStream = a((PGPSignatureList)localObject, paramInputStream, null, null, paramOutputStream, localA);
    }
    else if ((localObject instanceof PGPLiteralData))
    {
      paramInputStream = a((PGPLiteralData)localObject, null, paramOutputStream);
    }
    else
    {
      throw new NonPGPDataException("Unknown message format: " + localObject);
    }
    return paramInputStream;
  }
  
  public String[] decryptFileTo(String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException
  {
    a("Decrypting file {0}", paramString1);
    FileInputStream localFileInputStream = null;
    InputStream localInputStream = null;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFileName");
      paramString1 = a(localFileInputStream, localInputStream, paramString3, paramString4, paramString1);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String[] decryptFileTo(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    a("Decrypting file {0}", paramString1);
    FileInputStream localFileInputStream = null;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      paramString1 = a(localFileInputStream, paramKeyStore, paramString2, paramString3, paramString1);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
    }
  }
  
  public String decryptFile(String paramString1, InputStream paramInputStream, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    a("Decrypting file {0}", paramString1);
    a("Decrypting to {0}", new File(paramString3).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString3), 1048576);
      paramString1 = decryptStream(localBufferedInputStream, paramInputStream, paramString2, localBufferedOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramInputStream = new File(paramString3)).exists())) {
        paramInputStream.delete();
      }
    }
  }
  
  public String encryptString(String paramString1, String paramString2)
    throws PGPException, IOException
  {
    return encryptString(paramString1, paramString2, "UTF-8");
  }
  
  public String encryptString(String paramString1, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "publicKeyFileName");
      paramString1 = encryptString(paramString1, localInputStream, paramString3);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String encryptString(String paramString1, String[] paramArrayOfString, String paramString2)
    throws PGPException, IOException
  {
    Object localObject = new LinkedList();
    InputStream localInputStream = null;
    int n = 0;
    while (n < paramArrayOfString.length) {
      try
      {
        localInputStream = readFileOrAsciiString(paramArrayOfString[n], "publicKeyFileNames :" + n);
        ((List)localObject).add(localInputStream);
        IOUtil.closeStream(localInputStream);
      }
      finally
      {
        IOUtil.closeStream(localInputStream);
      }
    }
    InputStream[] arrayOfInputStream = (InputStream[])((List)localObject).toArray(new PGPPublicKey[((List)localObject).size()]);
    paramArrayOfString = null;
    localObject = null;
    try
    {
      localObject = new DirectByteArrayOutputStream(1048576);
      paramArrayOfString = new ByteArrayInputStream(paramString1.getBytes(paramString2));
      encryptStream(paramArrayOfString, "message.txt", arrayOfInputStream, (OutputStream)localObject, true, false);
      paramString1 = new String(((DirectByteArrayOutputStream)localObject).getArray(), 0, ((DirectByteArrayOutputStream)localObject).size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(paramArrayOfString);
      IOUtil.closeStream((OutputStream)localObject);
      for (paramArrayOfString = 0; paramArrayOfString < arrayOfInputStream.length; paramArrayOfString++) {
        IOUtil.closeStream(arrayOfInputStream[paramArrayOfString]);
      }
    }
  }
  
  public String encryptString(String paramString1, KeyStore paramKeyStore, String paramString2)
    throws PGPException, IOException
  {
    return encryptString(paramString1, paramKeyStore, paramString2, "UTF-8");
  }
  
  public String encryptString(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = a(paramKeyStore, paramString2);
      paramString1 = encryptString(paramString1, localInputStream, paramString3);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String encryptString(String paramString, KeyStore paramKeyStore, long paramLong)
    throws PGPException, IOException
  {
    return encryptString(paramString, paramKeyStore, paramLong, "UTF-8");
  }
  
  public String encryptString(String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = d(paramKeyStore, paramLong);
      paramString1 = encryptString(paramString1, localInputStream, paramString2);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String encryptString(String paramString1, KeyStore paramKeyStore, long[] paramArrayOfLong, String paramString2)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString2));
      encryptStream(localByteArrayInputStream, "message.txt", paramKeyStore, paramArrayOfLong, localDirectByteArrayOutputStream, true, false);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
    }
  }
  
  public String encryptString(String paramString1, KeyStore paramKeyStore, String[] paramArrayOfString, String paramString2)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString2));
      encryptStream(localByteArrayInputStream, "message.txt", paramKeyStore, paramArrayOfString, localDirectByteArrayOutputStream, true, false);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
    }
  }
  
  public String encryptString(String paramString, InputStream paramInputStream)
    throws PGPException, IOException
  {
    return encryptString(paramString, paramInputStream, "UTF-8");
  }
  
  public String encryptString(String paramString1, InputStream paramInputStream, String paramString2)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString2));
      encryptStream(localByteArrayInputStream, "message.txt", paramInputStream, localDirectByteArrayOutputStream, true, false);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
    }
  }
  
  public String signString(String paramString1, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFile");
      paramString1 = signString(paramString1, localInputStream, paramString3, "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String signString(String paramString1, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "privateKeyFile");
      paramString1 = signString(paramString1, localInputStream, paramString3, paramString4);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public String signString(String paramString1, InputStream paramInputStream, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString3));
      signStream(localByteArrayInputStream, "message.txt", paramInputStream, paramString2, localDirectByteArrayOutputStream, true);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
    }
  }
  
  public String signString(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, String paramString4)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString4));
      signStream(localByteArrayInputStream, "message.txt", paramKeyStore, paramString2, paramString3, localDirectByteArrayOutputStream, true);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
    }
  }
  
  public String signString(String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString3));
      signStream(localByteArrayInputStream, "message.txt", paramKeyStore, paramLong, paramString2, localDirectByteArrayOutputStream, true);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
    }
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString, InputStream[] paramArrayOfInputStream, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    try
    {
      PGPPublicKey[] arrayOfPGPPublicKey = new PGPPublicKey[paramArrayOfInputStream.length];
      for (int n = 0; n < paramArrayOfInputStream.length; n++) {
        arrayOfPGPPublicKey[n] = a(paramArrayOfInputStream[n]);
      }
      b(paramInputStream, paramString, arrayOfPGPPublicKey, paramOutputStream, new Date(), paramBoolean1, paramBoolean2, false);
      return;
    }
    finally
    {
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString1, long paramLong, String paramString2, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, IOException
  {
    encryptStream(paramInputStream, paramString1, paramLong, paramString2, paramOutputStream, paramBoolean, false);
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString1, long paramLong, String paramString2, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    FileInputStream localFileInputStream = null;
    try
    {
      localFileInputStream = new FileInputStream(new File(paramString2));
      encryptStream(paramInputStream, paramString1, paramLong, localFileInputStream, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
    }
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString1, KeyStore paramKeyStore, String paramString2, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    paramKeyStore = a(paramKeyStore, paramString2);
    try
    {
      encryptStream(paramInputStream, paramString1, paramKeyStore, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    finally
    {
      IOUtil.closeStream(paramKeyStore);
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString, KeyStore paramKeyStore, String[] paramArrayOfString, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    InputStream[] arrayOfInputStream = new InputStream[paramArrayOfString.length];
    for (int n = 0; n < paramArrayOfString.length; n++) {
      arrayOfInputStream[n] = a(paramKeyStore, paramArrayOfString[n]);
    }
    try
    {
      encryptStream(paramInputStream, paramString, arrayOfInputStream, paramOutputStream, paramBoolean1, paramBoolean2);
      for (n = 0; n < paramArrayOfString.length; n++) {
        IOUtil.closeStream(arrayOfInputStream[n]);
      }
      IOUtil.closeStream(paramInputStream);
      return;
    }
    finally
    {
      for (paramKeyStore = 0; paramKeyStore < paramArrayOfString.length; paramKeyStore++) {
        IOUtil.closeStream(arrayOfInputStream[paramKeyStore]);
      }
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString, KeyStore paramKeyStore, long[] paramArrayOfLong, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    InputStream[] arrayOfInputStream = new InputStream[paramArrayOfLong.length];
    for (int n = 0; n < paramArrayOfLong.length; n++)
    {
      PGPPublicKeyRing localPGPPublicKeyRing = paramKeyStore.b(paramArrayOfLong[n]);
      arrayOfInputStream[n] = new ByteArrayInputStream(localPGPPublicKeyRing.getEncoded());
    }
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      paramKeyStore = new byte[1048576];
      int i2;
      while ((i2 = paramInputStream.read(paramKeyStore)) > 0) {
        localDirectByteArrayOutputStream.write(paramKeyStore, 0, i2);
      }
      encryptStream(new ByteArrayInputStream(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size()), paramString, arrayOfInputStream, paramOutputStream, paramBoolean1, paramBoolean2);
      for (int i1 = 0; i1 < paramArrayOfLong.length; i1++) {
        IOUtil.closeStream(arrayOfInputStream[i1]);
      }
      IOUtil.closeStream(paramInputStream);
      return;
    }
    finally
    {
      for (paramKeyStore = 0; paramKeyStore < paramArrayOfLong.length; paramKeyStore++) {
        IOUtil.closeStream(arrayOfInputStream[paramKeyStore]);
      }
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString, KeyStore paramKeyStore, long paramLong, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    ;
    ByteArrayInputStream localByteArrayInputStream = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
    paramKeyStore = paramKeyStore.b(paramLong);
    try
    {
      paramKeyStore.encode(localDirectByteArrayOutputStream);
      localByteArrayInputStream = new ByteArrayInputStream(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size());
      paramKeyStore = new DirectByteArrayOutputStream(1048576);
      ??? = new byte[1048576];
      while ((paramLong = paramInputStream.read(???)) > 0) {
        paramKeyStore.write(???, 0, paramLong);
      }
      encryptStream(paramInputStream, paramString, paramKeyStore.size(), localByteArrayInputStream, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  public void encryptStream(InputStream paramInputStream1, String paramString, long paramLong, InputStream paramInputStream2, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    paramInputStream2 = a(paramInputStream2);
    paramInputStream1 = 0;
    paramBoolean1 = paramBoolean2;
    paramOutputStream = paramBoolean1;
    paramInputStream2 = paramOutputStream;
    ??? = new PGPPublicKey[] { paramInputStream2 };
    long l1 = paramLong;
    paramLong = paramString;
    paramString = paramInputStream1;
    paramInputStream1 = this;
    if (k)
    {
      paramInputStream1.a(paramString, paramLong, ???, paramInputStream2, paramOutputStream);
      return;
    }
    try
    {
      if (!(paramInputStream2 instanceof BufferedOutputStream)) {
        paramInputStream2 = new BufferedOutputStream(paramInputStream2, 1048576);
      }
      if (paramOutputStream != 0)
      {
        paramInputStream1.a("Output in ASCII armored format.");
        paramInputStream2 = paramInputStream2;
        paramInputStream2 = new ArmoredOutputStream(paramInputStream2);
        paramInputStream1.a(paramInputStream2);
      }
      paramBoolean2 = KeyStore.b(d);
      int n = KeyStore.c(c);
      if (???.length == 1)
      {
        paramBoolean2 = paramInputStream1.h(???[0]);
        n = paramInputStream1.f(???[0]);
        paramInputStream1.a("Encrypting with cypher {0}", KeyStore.c(n));
        paramInputStream1.a("Compression is {0}", KeyStore.a(paramBoolean2));
      }
      OutputStream localOutputStream1 = null;
      OutputStream localOutputStream2 = null;
      try
      {
        paramBoolean1 = new PGPEncryptedDataGenerator(a.CreatePGPDataEncryptorBuilder(n, paramBoolean1, IOUtil.getSecureRandom()));
        for (n = 0; n < ???.length; n++)
        {
          paramInputStream1.a("Encrypting with key {0} ", KeyPairInformation.keyId2Hex(???[n].getKeyID()));
          paramBoolean1.addMethod(a.CreatePublicKeyKeyEncryptionMethodGenerator(???[n]));
        }
        localOutputStream2 = paramBoolean1.open(paramInputStream2, new byte[1048576]);
        PGPCompressedDataGenerator localPGPCompressedDataGenerator = new PGPCompressedDataGenerator(paramBoolean2);
        if (!paramBoolean2) {
          a(localOutputStream2, paramInputStream1.getContentType(), paramString, paramLong, l1, new Date());
        } else {
          a(localOutputStream1 = localPGPCompressedDataGenerator.open(localOutputStream2), paramInputStream1.getContentType(), paramString, paramLong, l1, new Date());
        }
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
      {
        IOUtil.closeStream(localOutputStream1);
        IOUtil.closeStream(localOutputStream2);
        paramInputStream2.flush();
        if (paramOutputStream != 0) {
          IOUtil.closeStream(paramInputStream2);
        }
      }
      return;
    }
    catch (IOException localIOException)
    {
      throw (paramInputStream2 = localIOException);
    }
  }
  
  public void encryptStream(InputStream paramInputStream1, String paramString, InputStream paramInputStream2, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    try
    {
      paramInputStream2 = a(paramInputStream2);
      a(paramInputStream1, paramString, new PGPPublicKey[] { paramInputStream2 }, paramOutputStream, new Date(), paramBoolean1, paramBoolean2, false);
      return;
    }
    finally
    {
      IOUtil.closeStream(paramInputStream1);
    }
  }
  
  public void encryptStream(InputStream paramInputStream, String paramString, PGPKeyPair paramPGPKeyPair, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    try
    {
      Object localObject1 = paramPGPKeyPair.getRawPublicKeyRing();
      paramPGPKeyPair = this;
      Object localObject2 = null;
      Object localObject3 = null;
      localObject1 = ((PGPPublicKeyRing)localObject1).getPublicKeys();
      while ((localObject2 == null) && (((Iterator)localObject1).hasNext()))
      {
        PGPPublicKey localPGPPublicKey;
        if ((localPGPPublicKey = (PGPPublicKey)((Iterator)localObject1).next()).isEncryptionKey()) {
          if ((localPGPPublicKey.isRevoked()) && (!f))
          {
            paramPGPKeyPair.a("The key {0} is revoked", KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()));
            localObject3 = new KeyIsRevokedException("The key with Key Id:" + KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()) + " [" + a(localPGPPublicKey) + "] is revoked. See PGPLib.setUseRevokedKeys for more information.");
          }
          else if ((paramPGPKeyPair.b(localPGPPublicKey)) && (!e))
          {
            paramPGPKeyPair.a("The key {0} is expired", KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()));
            localObject3 = new KeyIsExpiredException("The key with Key Id:" + KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()) + " [" + a(localPGPPublicKey) + "] has expired. See PGPLib.setUseExpiredKeys for more information.");
          }
          else if ((localObject2 == null) || (localPGPPublicKey.getBitStrength() > localObject2.getBitStrength()))
          {
            localObject2 = localPGPPublicKey;
          }
        }
      }
      if (localObject2 == null)
      {
        if (localObject3 != null) {
          throw ((Throwable)localObject3);
        }
        throw new NoPublicKeyFoundException("Can't find encryption key in key ring.");
      }
      paramPGPKeyPair = localObject2;
      a(paramInputStream, paramString, new PGPPublicKey[] { paramPGPKeyPair }, paramOutputStream, new Date(), paramBoolean1, paramBoolean2, false);
      return;
    }
    finally
    {
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  public String encryptStringPBE(String paramString1, String paramString2)
    throws PGPException, IOException
  {
    return encryptStringPBE(paramString1, paramString2, "UTF-8");
  }
  
  public String encryptStringPBE(String paramString1, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    ByteArrayInputStream localByteArrayInputStream = null;
    try
    {
      DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString3));
      encryptStreamPBE(localByteArrayInputStream, "message.txt", paramString2, localDirectByteArrayOutputStream, true, false);
      paramString1 = new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), "UTF-8");
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
    }
  }
  
  public void encryptStreamPBE(InputStream paramInputStream, String paramString1, String paramString2, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    try
    {
      a(paramInputStream, paramString1, paramString2, paramOutputStream, paramBoolean1, paramBoolean2);
      return;
    }
    finally
    {
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  public void encryptFilePBE(String paramString1, String paramString2, String paramString3, String paramString4, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    Object localObject = new File(paramString1);
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    a("Password encrypting file {0}", paramString1);
    a("Encrypting to {0}", new File(paramString4).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString4), 1048576);
      localInputStream = readFileOrAsciiString(paramString2, "publicKeyFileName");
      paramString1 = a(localInputStream);
      boolean bool2 = paramBoolean2;
      boolean bool1 = paramBoolean1;
      localObject = localBufferedOutputStream;
      paramBoolean2 = paramString3;
      paramBoolean1 = paramString1;
      long l1 = ((File)localObject).length();
      paramString3 = ((File)localObject).getName();
      paramString2 = localBufferedInputStream;
      paramString1 = this;
      if (!(localObject instanceof BufferedOutputStream)) {
        localObject = new BufferedOutputStream((OutputStream)localObject, 1048576);
      }
      try
      {
        if (bool1)
        {
          localObject = localObject;
          localObject = new ArmoredOutputStream((OutputStream)localObject);
          paramString1.a((OutputStream)localObject);
        }
        OutputStream localOutputStream = null;
        try
        {
          int i1 = paramString1.h(paramBoolean1);
          PGPCompressedDataGenerator localPGPCompressedDataGenerator = new PGPCompressedDataGenerator(i1);
          int i2 = paramString1.f(paramBoolean1);
          PGPEncryptedDataGenerator localPGPEncryptedDataGenerator;
          (localPGPEncryptedDataGenerator = a.CreatePGPEncryptedDataGenerator(i2, bool2, IOUtil.getSecureRandom())).addMethod(a.CreatePublicKeyKeyEncryptionMethodGenerator(paramBoolean1));
          paramString1.a("Encrypting with key {0} ", KeyPairInformation.keyId2Hex(paramBoolean1.getKeyID()));
          localPGPEncryptedDataGenerator.addMethod(a.CreatePBEKeyEncryptionMethodGenerator(paramBoolean2));
          paramString1.a("Encrypting with password");
          localOutputStream = localPGPEncryptedDataGenerator.open((OutputStream)localObject, new byte[1048576]);
          if (i1 == 0) {
            a(localOutputStream, paramString1.getContentType(), paramString2, paramString3, l1, new Date());
          } else {
            a(localPGPCompressedDataGenerator.open(localOutputStream), paramString1.getContentType(), paramString2, paramString3, l1, new Date());
          }
        }
        catch (lw.bouncycastle.openpgp.PGPException localPGPException2) {}finally
        {
          lw.bouncycastle.openpgp.PGPException localPGPException1;
          IOUtil.closeStream(null);
          IOUtil.closeStream(localOutputStream);
          ((OutputStream)localObject).flush();
          if (bool1) {
            IOUtil.closeStream((OutputStream)localObject);
          }
        }
      }
      catch (IOException localIOException)
      {
        throw new PGPException(localIOException.getMessage(), localIOException);
      }
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString4)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void encryptFilePBE(String paramString1, String paramString2, String paramString3, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    File localFile = new File(paramString1);
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    a("Password encrypting file {0}", paramString1);
    a("Encrypting to {0}", new File(paramString3).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString3), 1048576);
      a(localBufferedInputStream, localFile.getName(), paramString2, localBufferedOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(null);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(null);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString3)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public void encryptFile(String paramString1, String paramString2, String paramString3, boolean paramBoolean)
    throws PGPException, IOException
  {
    encryptFile(paramString1, paramString2, paramString3, paramBoolean, false);
  }
  
  public void encryptFile(String paramString1, String paramString2, String paramString3, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString2, "publicKeyFileName");
      encryptFile(paramString1, localInputStream, paramString3, paramBoolean1, paramBoolean2);
      return;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public void encryptFile(String paramString1, String[] paramArrayOfString, String paramString2, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting file {0}", paramString1);
    a("Encrypting to {0}", new File(paramString2).getAbsolutePath());
    LinkedList localLinkedList = new LinkedList();
    InputStream localInputStream = null;
    int i1 = 0;
    while (i1 < paramArrayOfString.length) {
      try
      {
        localInputStream = readFileOrAsciiString(paramArrayOfString[i1], "publicKeysFileNames :" + i1);
        localObject = a(localInputStream);
        localLinkedList.add(localObject);
        IOUtil.closeStream(localInputStream);
      }
      finally
      {
        IOUtil.closeStream(localInputStream);
      }
    }
    PGPPublicKey[] arrayOfPGPPublicKey = (PGPPublicKey[])localLinkedList.toArray(new PGPPublicKey[localLinkedList.size()]);
    Object localObject = null;
    paramArrayOfString = null;
    int n = 0;
    try
    {
      paramString1 = new File(paramString1);
      localObject = new FileInputStream(paramString1);
      paramArrayOfString = new FileOutputStream(paramString2);
      a((InputStream)localObject, paramString1.getName(), arrayOfPGPPublicKey, paramArrayOfString, new Date(paramString1.lastModified()), paramBoolean1, paramBoolean2, false);
      IOUtil.closeStream((InputStream)localObject);
      IOUtil.closeStream(paramArrayOfString);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      n = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream((InputStream)localObject);
      IOUtil.closeStream(paramArrayOfString);
      if ((n != 0) && ((paramArrayOfString = new File(paramString2)).exists())) {
        paramArrayOfString.delete();
      }
    }
  }
  
  public void encryptFile(String paramString1, KeyStore paramKeyStore, String[] paramArrayOfString, String paramString2, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting file {0}", paramString1);
    a("Encrypting to {0}", new File(paramString2).getAbsolutePath());
    LinkedList localLinkedList = new LinkedList();
    InputStream localInputStream = null;
    int n = 0;
    while (n < paramArrayOfString.length) {
      try
      {
        localInputStream = a(paramKeyStore, paramArrayOfString[n]);
        localObject = a(localInputStream);
        localLinkedList.add(localObject);
        IOUtil.closeStream(localInputStream);
      }
      finally
      {
        IOUtil.closeStream(localInputStream);
      }
    }
    PGPPublicKey[] arrayOfPGPPublicKey = (PGPPublicKey[])localLinkedList.toArray(new PGPPublicKey[localLinkedList.size()]);
    Object localObject = null;
    paramKeyStore = null;
    paramArrayOfString = 0;
    try
    {
      paramString1 = new File(paramString1);
      localObject = new FileInputStream(paramString1);
      paramKeyStore = new FileOutputStream(paramString2);
      a((InputStream)localObject, paramString1.getName(), arrayOfPGPPublicKey, paramKeyStore, new Date(paramString1.lastModified()), paramBoolean1, paramBoolean2, false);
      IOUtil.closeStream((InputStream)localObject);
      IOUtil.closeStream(paramKeyStore);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      paramArrayOfString = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      paramArrayOfString = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream((InputStream)localObject);
      IOUtil.closeStream(paramKeyStore);
      if ((paramArrayOfString != 0) && ((paramKeyStore = new File(paramString2)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void encryptFile(String paramString1, KeyStore paramKeyStore, long[] paramArrayOfLong, String paramString2, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting file {0}", paramString1);
    a("Encrypting to {0}", new File(paramString2).getAbsolutePath());
    LinkedList localLinkedList = new LinkedList();
    InputStream localInputStream = null;
    int n = 0;
    while (n < paramArrayOfLong.length) {
      try
      {
        localInputStream = d(paramKeyStore, paramArrayOfLong[n]);
        localObject = a(localInputStream);
        localLinkedList.add(localObject);
        IOUtil.closeStream(localInputStream);
      }
      finally
      {
        IOUtil.closeStream(localInputStream);
      }
    }
    PGPPublicKey[] arrayOfPGPPublicKey = (PGPPublicKey[])localLinkedList.toArray(new PGPPublicKey[localLinkedList.size()]);
    Object localObject = null;
    paramKeyStore = null;
    paramArrayOfLong = 0;
    try
    {
      paramString1 = new File(paramString1);
      localObject = new FileInputStream(paramString1);
      paramKeyStore = new FileOutputStream(paramString2);
      a((InputStream)localObject, paramString1.getName(), arrayOfPGPPublicKey, paramKeyStore, new Date(paramString1.lastModified()), paramBoolean1, paramBoolean2, false);
      IOUtil.closeStream((InputStream)localObject);
      IOUtil.closeStream(paramKeyStore);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramString1)
    {
      paramArrayOfLong = 1;
      throw IOUtil.newPGPException(paramString1);
    }
    catch (IOException paramString1)
    {
      paramArrayOfLong = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream((InputStream)localObject);
      IOUtil.closeStream(paramKeyStore);
      if ((paramArrayOfLong != 0) && ((paramKeyStore = new File(paramString2)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void encryptFiles(String[] paramArrayOfString, String paramString1, String paramString2, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    encryptFiles(paramArrayOfString, new String[] { paramString1 }, paramString2, paramBoolean1, paramBoolean2);
  }
  
  public void encryptFiles(String[] paramArrayOfString1, String[] paramArrayOfString2, String paramString, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting multiple files");
    a("Encrypting to {0}", new File(paramString).getAbsolutePath());
    if (paramArrayOfString1.length == 0) {
      throw new IllegalArgumentException("Please specify at least one file to be encrypted.");
    }
    Object localObject1 = new LinkedList();
    Object localObject2 = null;
    int n = 0;
    while (n < paramArrayOfString2.length) {
      try
      {
        localObject2 = readFileOrAsciiString(paramArrayOfString2[n], "publicKeysFileNames :" + n);
        localObject3 = a((InputStream)localObject2);
        ((List)localObject1).add(localObject3);
        IOUtil.closeStream((InputStream)localObject2);
      }
      finally
      {
        IOUtil.closeStream((InputStream)localObject2);
      }
    }
    PGPPublicKey[] arrayOfPGPPublicKey = (PGPPublicKey[])((List)localObject1).toArray(new PGPPublicKey[((List)localObject1).size()]);
    Object localObject3 = null;
    paramArrayOfString2 = 0;
    localObject1 = paramArrayOfString1[0];
    if (paramArrayOfString1.length > 1)
    {
      localObject3 = a(paramArrayOfString1);
      paramArrayOfString2 = 1;
      localObject1 = ((File)localObject3).getAbsolutePath();
    }
    paramArrayOfString1 = null;
    localObject2 = null;
    int i1 = 0;
    char c1 = i;
    try
    {
      localObject1 = new File((String)localObject1);
      paramArrayOfString1 = new BufferedInputStream(new FileInputStream((File)localObject1), 1048576);
      localObject2 = new BufferedOutputStream(new FileOutputStream(paramString), 1048576);
      if (paramArrayOfString2 != 0) {
        i = 'b';
      }
      a(paramArrayOfString1, ((File)localObject1).getName(), arrayOfPGPPublicKey, (OutputStream)localObject2, new Date(((File)localObject1).lastModified()), paramBoolean1, paramBoolean2, paramArrayOfString2);
      i = c1;
      IOUtil.closeStream(paramArrayOfString1);
      IOUtil.closeStream((OutputStream)localObject2);
      if (localObject3 != null) {
        ((File)localObject3).delete();
      }
      return;
    }
    catch (PGPException paramArrayOfString2)
    {
      i1 = 1;
      throw paramArrayOfString2;
    }
    catch (IOException paramArrayOfString2)
    {
      i1 = 1;
      throw paramArrayOfString2;
    }
    finally
    {
      i = c1;
      IOUtil.closeStream(paramArrayOfString1);
      IOUtil.closeStream((OutputStream)localObject2);
      if (localObject3 != null) {
        ((File)localObject3).delete();
      }
      if ((i1 != 0) && ((paramArrayOfString1 = new File(paramString)).exists())) {
        paramArrayOfString1.delete();
      }
    }
  }
  
  public void encryptFiles(String[] paramArrayOfString1, KeyStore paramKeyStore, String[] paramArrayOfString2, String paramString, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting multiple files");
    a("Encrypting to {0}", new File(paramString).getAbsolutePath());
    if (paramArrayOfString1.length == 0) {
      throw new IllegalArgumentException("please specify at least one file name to be encrypted.");
    }
    Object localObject1 = new LinkedList();
    InputStream localInputStream = null;
    int i1 = 0;
    while (i1 < paramArrayOfString2.length) {
      try
      {
        localInputStream = a(paramKeyStore, paramArrayOfString2[i1]);
        localObject2 = a(localInputStream);
        ((List)localObject1).add(localObject2);
        IOUtil.closeStream(localInputStream);
      }
      finally
      {
        IOUtil.closeStream(localInputStream);
      }
    }
    PGPPublicKey[] arrayOfPGPPublicKey = (PGPPublicKey[])((List)localObject1).toArray(new PGPPublicKey[((List)localObject1).size()]);
    Object localObject2 = null;
    paramKeyStore = 0;
    paramArrayOfString2 = paramArrayOfString1[0];
    if (paramArrayOfString1.length > 1)
    {
      localObject2 = a(paramArrayOfString1);
      paramKeyStore = 1;
      paramArrayOfString2 = ((File)localObject2).getAbsolutePath();
    }
    paramArrayOfString1 = null;
    localObject1 = null;
    int n = 0;
    char c1 = i;
    try
    {
      paramArrayOfString2 = new File(paramArrayOfString2);
      paramArrayOfString1 = new BufferedInputStream(new FileInputStream(paramArrayOfString2), 1048576);
      localObject1 = new BufferedOutputStream(new FileOutputStream(paramString), 1048576);
      if (paramKeyStore != 0) {
        i = 'b';
      }
      a(paramArrayOfString1, paramArrayOfString2.getName(), arrayOfPGPPublicKey, (OutputStream)localObject1, new Date(paramArrayOfString2.lastModified()), paramBoolean1, paramBoolean2, paramKeyStore);
      i = c1;
      IOUtil.closeStream(paramArrayOfString1);
      IOUtil.closeStream((OutputStream)localObject1);
      if (localObject2 != null) {
        ((File)localObject2).delete();
      }
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramKeyStore)
    {
      n = 1;
      throw IOUtil.newPGPException(paramKeyStore);
    }
    catch (IOException paramKeyStore)
    {
      n = 1;
      throw paramKeyStore;
    }
    finally
    {
      i = c1;
      IOUtil.closeStream(paramArrayOfString1);
      IOUtil.closeStream((OutputStream)localObject1);
      if (localObject2 != null) {
        ((File)localObject2).delete();
      }
      if ((n != 0) && ((paramArrayOfString1 = new File(paramString)).exists())) {
        paramArrayOfString1.delete();
      }
    }
  }
  
  public void encryptFiles(String[] paramArrayOfString, KeyStore paramKeyStore, long[] paramArrayOfLong, String paramString, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting multiple files");
    a("Encrypting to {0}", new File(paramString).getAbsolutePath());
    if (paramArrayOfString.length == 0) {
      throw new IllegalArgumentException("please specify at least one file name to be encrypted.");
    }
    Object localObject1 = new LinkedList();
    InputStream localInputStream = null;
    int i1 = 0;
    while (i1 < paramArrayOfLong.length) {
      try
      {
        localInputStream = d(paramKeyStore, paramArrayOfLong[i1]);
        localObject2 = a(localInputStream);
        ((List)localObject1).add(localObject2);
        IOUtil.closeStream(localInputStream);
      }
      finally
      {
        IOUtil.closeStream(localInputStream);
      }
    }
    PGPPublicKey[] arrayOfPGPPublicKey = (PGPPublicKey[])((List)localObject1).toArray(new PGPPublicKey[((List)localObject1).size()]);
    Object localObject2 = null;
    paramKeyStore = 0;
    paramArrayOfLong = paramArrayOfString[0];
    if (paramArrayOfString.length > 1)
    {
      localObject2 = a(paramArrayOfString);
      paramKeyStore = 1;
      paramArrayOfLong = ((File)localObject2).getAbsolutePath();
    }
    paramArrayOfString = null;
    localObject1 = null;
    int n = 0;
    char c1 = i;
    try
    {
      paramArrayOfLong = new File(paramArrayOfLong);
      paramArrayOfString = new BufferedInputStream(new FileInputStream(paramArrayOfLong), 1048576);
      localObject1 = new BufferedOutputStream(new FileOutputStream(paramString), 1048576);
      if (paramKeyStore != 0) {
        i = 'b';
      }
      a(paramArrayOfString, paramArrayOfLong.getName(), arrayOfPGPPublicKey, (OutputStream)localObject1, new Date(paramArrayOfLong.lastModified()), paramBoolean1, paramBoolean2, paramKeyStore);
      i = c1;
      IOUtil.closeStream(paramArrayOfString);
      IOUtil.closeStream((OutputStream)localObject1);
      if (localObject2 != null) {
        ((File)localObject2).delete();
      }
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException paramKeyStore)
    {
      n = 1;
      throw IOUtil.newPGPException(paramKeyStore);
    }
    catch (IOException paramKeyStore)
    {
      n = 1;
      throw paramKeyStore;
    }
    finally
    {
      i = c1;
      IOUtil.closeStream(paramArrayOfString);
      IOUtil.closeStream((OutputStream)localObject1);
      if (localObject2 != null) {
        ((File)localObject2).delete();
      }
      if ((n != 0) && ((paramArrayOfString = new File(paramString)).exists())) {
        paramArrayOfString.delete();
      }
    }
  }
  
  public void encryptFile(String paramString1, InputStream paramInputStream, String paramString2, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting file {0}", paramString1);
    a("Encrypting to {0}", new File(paramString2).getAbsolutePath());
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    int n = 0;
    try
    {
      paramString1 = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString2), 1048576);
      paramInputStream = a(paramInputStream);
      a(localBufferedInputStream, paramString1.getName(), new PGPPublicKey[] { paramInputStream }, localBufferedOutputStream, new Date(paramString1.lastModified()), paramBoolean1, paramBoolean2, false);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return;
    }
    catch (PGPException paramInputStream)
    {
      n = 1;
      throw paramInputStream;
    }
    catch (IOException paramInputStream)
    {
      n = 1;
      throw paramInputStream;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramInputStream = new File(paramString2)).exists())) {
        paramInputStream.delete();
      }
    }
  }
  
  /**
   * @deprecated
   */
  public int encryptFileByUserId(KeyStore paramKeyStore, String paramString1, String paramString2, String paramString3)
  {
    try
    {
      encryptFile(paramString1, paramKeyStore, paramString2, paramString3);
    }
    catch (Exception localException)
    {
      return 1;
    }
    return 0;
  }
  
  public void encryptFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    a("Encrypting file {0}", paramString1);
    a("Encrypting to {0}", new File(paramString3).getAbsolutePath());
    paramKeyStore = a(paramKeyStore, paramString2);
    paramString2 = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      File localFile = new File(paramString1);
      paramString2 = new FileInputStream(paramString1);
      localFileOutputStream = new FileOutputStream(paramString3);
      encryptStream(paramString2, localFile.getName(), paramKeyStore, localFileOutputStream, paramBoolean1, paramBoolean2);
      IOUtil.closeStream(paramString2);
      IOUtil.closeStream(localFileOutputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      n = 1;
      throw IOUtil.newPGPException(localPGPException);
    }
    catch (IOException localIOException)
    {
      n = 1;
      throw localIOException;
    }
    finally
    {
      IOUtil.closeStream(paramString2);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString3)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void encryptFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    encryptFile(paramString1, paramKeyStore, paramString2, paramString3, false, false);
  }
  
  /**
   * @deprecated
   */
  public int encryptFileByKeyId(KeyStore paramKeyStore, String paramString1, String paramString2, String paramString3)
  {
    try
    {
      encryptFile(paramString1, paramKeyStore, Long.decode(paramString2).longValue(), paramString3);
    }
    catch (Exception localException)
    {
      return 0;
    }
    return 1;
  }
  
  public void encryptFile(String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    InputStream localInputStream = null;
    a("Encrypting file {0}", new File(paramString1).getAbsolutePath());
    a("Encrypting to {0}", new File(paramString2).getAbsolutePath());
    int n = 0;
    try
    {
      File localFile = new File(paramString1);
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString2), 1048576);
      localInputStream = d(paramKeyStore, paramLong);
      paramString1 = a(localInputStream);
      a(localBufferedInputStream, localFile.getName(), new PGPPublicKey[] { paramString1 }, localBufferedOutputStream, new Date(localFile.lastModified()), paramBoolean1, paramBoolean2, false);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream);
      return;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      n = 1;
      throw IOUtil.newPGPException(localPGPException);
    }
    catch (IOException localIOException)
    {
      n = 1;
      throw localIOException;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      IOUtil.closeStream(localInputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString2)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public void encryptFile(String paramString1, KeyStore paramKeyStore, long paramLong, String paramString2)
    throws PGPException, IOException
  {
    encryptFile(paramString1, paramKeyStore, paramLong, paramString2, false, false);
  }
  
  /**
   * @deprecated
   */
  public boolean verifyFile(String paramString1, String paramString2, String paramString3)
    throws PGPException, FileIsEncryptedException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    a("Signature verification of file {0}", paramString1);
    a("Extracting to {0}", new File(paramString3).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localInputStream = readFileOrAsciiString(paramString2, "publicKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString3), 1048576);
      paramString1 = verifyStream(localBufferedInputStream, localInputStream, localBufferedOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString3)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  /**
   * @deprecated
   */
  public boolean verifyFile(String paramString1, KeyStore paramKeyStore, String paramString2)
    throws PGPException, FileIsEncryptedException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    FileOutputStream localFileOutputStream = null;
    a("Signature verification of file {0}", paramString1);
    a("Extracting to {0}", new File(paramString2).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1));
      localFileOutputStream = new FileOutputStream(paramString2);
      paramString1 = verifyStream(localBufferedInputStream, paramKeyStore, localFileOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString2)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  /**
   * @deprecated
   */
  public boolean verifyFile(String paramString1, String paramString2)
    throws PGPException, FileIsEncryptedException, IOException
  {
    a("Signature verification of file {0}", paramString1);
    FileInputStream localFileInputStream = null;
    InputStream localInputStream = null;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localInputStream = readFileOrAsciiString(paramString2, "publicKeyFileName");
      paramString1 = verifyStream(localFileInputStream, localInputStream);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean verifyFile(InputStream paramInputStream1, InputStream paramInputStream2)
    throws PGPException, IOException
  {
    return verifyStream(paramInputStream1, paramInputStream2);
  }
  
  public SignatureCheckResult verifyWithoutExtracting(InputStream paramInputStream1, InputStream paramInputStream2)
    throws PGPException, FileIsEncryptedException, IOException
  {
    if ((((paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1)) instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream1).isClearText())) {
      return (paramInputStream1 = new PGPLib.1(this)).b((ArmoredInputStream)localObject, null, paramInputStream2, new DummyStream());
    }
    Object localObject = new PGPObjectFactory2(paramInputStream1);
    try
    {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((paramInputStream1 instanceof PGPMarker)) {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream1 instanceof PGPEncryptedDataList)) {
      throw new FileIsEncryptedException("This file is encrypted. Use the methods <decryptAndVerifySignature> or <decrypt> to open it.");
    }
    if ((paramInputStream1 instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream1, true, localA, null, paramInputStream2, new DummyStream());
    } else if ((paramInputStream1 instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream2, new DummyStream(), localA);
    } else if ((paramInputStream1 instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream2, new DummyStream(), localA);
    } else if ((paramInputStream1 instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream1, null, new DummyStream());
    } else {
      throw new NonPGPDataException("Unknown message format: " + paramInputStream1.getClass());
    }
    return a;
  }
  
  public SignatureCheckResult verifyWithoutExtracting(InputStream paramInputStream1, InputStream paramInputStream2, String paramString, InputStream paramInputStream3)
    throws PGPException, FileIsEncryptedException, IOException
  {
    if ((((paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1)) instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream1).isClearText())) {
      return (paramInputStream1 = new PGPLib.1(this)).b((ArmoredInputStream)localObject, null, paramInputStream3, new DummyStream());
    }
    Object localObject = new PGPObjectFactory2(paramInputStream1);
    try
    {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((paramInputStream1 instanceof PGPMarker)) {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream1 instanceof PGPEncryptedDataList)) {
      a((PGPEncryptedDataList)paramInputStream1, true, localA, null, paramInputStream2, paramString, paramInputStream3, new DummyStream());
    } else if ((paramInputStream1 instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream1, true, localA, null, paramInputStream3, new DummyStream());
    } else if ((paramInputStream1 instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream3, new DummyStream(), localA);
    } else if ((paramInputStream1 instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream3, new DummyStream(), localA);
    } else if ((paramInputStream1 instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream1, null, new DummyStream());
    } else {
      throw new NonPGPDataException("Unknown message format: " + paramInputStream1.getClass());
    }
    return a;
  }
  
  public SignatureCheckResult verifyWithoutExtracting(InputStream paramInputStream, KeyStore paramKeyStore, String paramString)
    throws PGPException, FileIsEncryptedException, IOException
  {
    paramInputStream = PGPUtil.getDecoderStream(paramInputStream);
    DummyStream localDummyStream = new DummyStream();
    if (((paramInputStream instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream).isClearText())) {
      return (paramInputStream = new PGPLib.1(this)).b((ArmoredInputStream)localObject, paramKeyStore, null, localDummyStream);
    }
    Object localObject = new PGPObjectFactory2(paramInputStream);
    try
    {
      paramInputStream = ((PGPObjectFactory2)localObject).nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((paramInputStream instanceof PGPMarker)) {
      paramInputStream = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream instanceof PGPEncryptedDataList)) {
      a((PGPEncryptedDataList)paramInputStream, true, localA, paramKeyStore, null, paramString, null, localDummyStream);
    } else if ((paramInputStream instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream, true, localA, paramKeyStore, null, localDummyStream);
    } else if ((paramInputStream instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, localDummyStream, localA);
    } else if ((paramInputStream instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, localDummyStream, localA);
    } else if ((paramInputStream instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream, null, localDummyStream);
    } else {
      throw new NonPGPDataException("Unknown message format: " + paramInputStream.getClass());
    }
    return a;
  }
  
  public SignatureCheckResult verifyWithoutExtracting(InputStream paramInputStream, KeyStore paramKeyStore)
    throws PGPException, FileIsEncryptedException, IOException
  {
    paramInputStream = PGPUtil.getDecoderStream(paramInputStream);
    DummyStream localDummyStream = new DummyStream();
    if (((paramInputStream instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream).isClearText())) {
      return (paramInputStream = new PGPLib.1(this)).b((ArmoredInputStream)localObject, paramKeyStore, null, localDummyStream);
    }
    Object localObject = new PGPObjectFactory2(paramInputStream);
    try
    {
      paramInputStream = ((PGPObjectFactory2)localObject).nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((paramInputStream instanceof PGPMarker)) {
      paramInputStream = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream instanceof PGPEncryptedDataList)) {
      throw new FileIsEncryptedException("This file is encrypted. Use <decryptAndVerify> or <decrypt> to open it.");
    }
    if ((paramInputStream instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream, true, localA, paramKeyStore, null, localDummyStream);
    } else if ((paramInputStream instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, localDummyStream, localA);
    } else if ((paramInputStream instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, localDummyStream, localA);
    } else if ((paramInputStream instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream, null, localDummyStream);
    } else {
      throw new NonPGPDataException("Unknown message format: " + paramInputStream.getClass());
    }
    return a;
  }
  
  public SignatureCheckResult verifyWithoutExtracting(String paramString1, String paramString2, String paramString3, String paramString4)
    throws IOException, PGPException, FileIsEncryptedException
  {
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    DummyStream localDummyStream = new DummyStream();
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString1, "message");
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFile");
      paramString1 = readFileOrAsciiString(paramString2, "privateKeyFile");
      paramString1 = paramString1 = verifyWithoutExtracting(localInputStream1, paramString1, paramString3, localInputStream2);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localDummyStream);
    }
  }
  
  public SignatureCheckResult verifyWithoutExtracting(String paramString1, String paramString2)
    throws IOException, PGPException, FileIsEncryptedException
  {
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    DummyStream localDummyStream = new DummyStream();
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString1, "message");
      localInputStream2 = readFileOrAsciiString(paramString2, "publicKeyFile");
      paramString1 = paramString1 = verifyAndExtract(localInputStream1, localInputStream2, localDummyStream);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localDummyStream);
    }
  }
  
  public SignatureCheckResult verifyWithoutExtracting(String paramString, KeyStore paramKeyStore)
    throws IOException, PGPException, FileIsEncryptedException
  {
    InputStream localInputStream = null;
    DummyStream localDummyStream = new DummyStream();
    try
    {
      localInputStream = readFileOrAsciiString(paramString, "message");
      paramString = paramString = verifyAndExtract(localInputStream, paramKeyStore, localDummyStream);
      return paramString;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localDummyStream);
    }
  }
  
  public SignatureCheckResult verifyWithoutExtracting(String paramString1, KeyStore paramKeyStore, String paramString2)
    throws IOException, PGPException, FileIsEncryptedException
  {
    InputStream localInputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString1, "message");
      paramString1 = paramString1 = verifyWithoutExtracting(localInputStream, paramKeyStore, paramString2);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public SignatureCheckResult verifyWithoutExtracting(File paramFile1, File paramFile2)
    throws PGPException, FileIsEncryptedException, IOException
  {
    return verifyWithoutExtracting(paramFile1.getAbsolutePath(), paramFile2.getAbsolutePath());
  }
  
  public SignatureCheckResult verifyWithoutExtracting(File paramFile1, File paramFile2, String paramString, File paramFile3)
    throws PGPException, FileIsEncryptedException, IOException
  {
    return verifyWithoutExtracting(paramFile1.getAbsolutePath(), paramFile2.getAbsolutePath(), paramString, paramFile3.getAbsolutePath());
  }
  
  public SignatureCheckResult verifyWithoutExtracting(File paramFile, KeyStore paramKeyStore)
    throws PGPException, FileIsEncryptedException, IOException
  {
    return verifyWithoutExtracting(paramFile.getAbsolutePath(), paramKeyStore);
  }
  
  public SignatureCheckResult verifyWithoutExtracting(File paramFile, KeyStore paramKeyStore, String paramString)
    throws PGPException, FileIsEncryptedException, IOException
  {
    return verifyWithoutExtracting(paramFile.getAbsolutePath(), paramKeyStore, paramString);
  }
  
  public SignatureCheckResult verifyAndExtract(InputStream paramInputStream1, InputStream paramInputStream2, OutputStream paramOutputStream)
    throws PGPException, FileIsEncryptedException, IOException
  {
    if ((((paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1)) instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream1).isClearText())) {
      return (paramInputStream1 = new PGPLib.1(this)).b((ArmoredInputStream)localObject, null, paramInputStream2, paramOutputStream);
    }
    Object localObject = new PGPObjectFactory2(paramInputStream1);
    try
    {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((paramInputStream1 instanceof PGPMarker)) {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream1 instanceof PGPEncryptedDataList)) {
      throw new FileIsEncryptedException("This file is encrypted. Use the methods <decryptAndVerifySignature> or <decrypt> to open it.");
    }
    if ((paramInputStream1 instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream1, true, localA, null, paramInputStream2, paramOutputStream);
    } else if ((paramInputStream1 instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream2, paramOutputStream, localA);
    } else if ((paramInputStream1 instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream2, paramOutputStream, localA);
    } else if ((paramInputStream1 instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream1, null, paramOutputStream);
    } else {
      throw new NonPGPDataException("Unknown message format: " + paramInputStream1.getClass());
    }
    return a;
  }
  
  public SignatureCheckResult verifyAndExtract(InputStream paramInputStream, KeyStore paramKeyStore, OutputStream paramOutputStream)
    throws PGPException, FileIsEncryptedException, IOException
  {
    if ((((paramInputStream = PGPUtil.getDecoderStream(paramInputStream)) instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream).isClearText())) {
      return (paramInputStream = new PGPLib.1(this)).b((ArmoredInputStream)localObject, paramKeyStore, null, paramOutputStream);
    }
    Object localObject = new PGPObjectFactory2(paramInputStream);
    try
    {
      paramInputStream = ((PGPObjectFactory2)localObject).nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((paramInputStream instanceof PGPMarker)) {
      paramInputStream = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream instanceof PGPEncryptedDataList)) {
      throw new FileIsEncryptedException("This file is encrypted. Use <decryptAndVerify> or <decrypt> to open it.");
    }
    if ((paramInputStream instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream, true, localA, paramKeyStore, null, paramOutputStream);
    } else if ((paramInputStream instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, paramOutputStream, localA);
    } else if ((paramInputStream instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, paramOutputStream, localA);
    } else if ((paramInputStream instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream, null, paramOutputStream);
    } else {
      throw new NonPGPDataException("Unknown message format: " + paramInputStream.getClass());
    }
    return a;
  }
  
  public SignatureCheckResult verifyAndExtract(String paramString1, String paramString2, StringBuffer paramStringBuffer, String paramString3)
    throws IOException, PGPException, FileIsEncryptedException
  {
    if (paramStringBuffer == null) {
      throw new IllegalArgumentException("The decryptedString parameter cannot be null");
    }
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localInputStream1 = readFileOrAsciiString(paramString1, "message");
      localInputStream2 = readFileOrAsciiString(paramString2, "publicKeyFile");
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      paramString1 = verifyAndExtract(localInputStream1, localInputStream2, localDirectByteArrayOutputStream);
      paramStringBuffer.setLength(0);
      paramStringBuffer.append(new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString3));
      paramString1 = paramString1;
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  public SignatureCheckResult verifyAndExtract(String paramString1, String paramString2, StringBuffer paramStringBuffer)
    throws IOException, PGPException, FileIsEncryptedException
  {
    return verifyAndExtract(paramString1, paramString2, paramStringBuffer, "ASCII");
  }
  
  public SignatureCheckResult verifyAndExtract(String paramString1, KeyStore paramKeyStore, StringBuffer paramStringBuffer, String paramString2)
    throws IOException, PGPException, FileIsEncryptedException
  {
    if (paramStringBuffer == null) {
      throw new IllegalArgumentException("The decryptedString parameter cannot be null");
    }
    InputStream localInputStream = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localInputStream = readFileOrAsciiString(paramString1, "message");
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      paramString1 = verifyAndExtract(localInputStream, paramKeyStore, localDirectByteArrayOutputStream);
      paramStringBuffer.setLength(0);
      paramStringBuffer.append(new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString2));
      paramString1 = paramString1;
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  public SignatureCheckResult verifyAndExtract(String paramString, KeyStore paramKeyStore, StringBuffer paramStringBuffer)
    throws IOException, PGPException, FileIsEncryptedException
  {
    return verifyAndExtract(paramString, paramKeyStore, paramStringBuffer);
  }
  
  public SignatureCheckResult verifyAndExtract(String paramString1, String paramString2, String paramString3)
    throws PGPException, FileIsEncryptedException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    InputStream localInputStream = null;
    BufferedOutputStream localBufferedOutputStream = null;
    a("Signature verification of file {0}", paramString1);
    a("Extracting to {0}", new File(paramString3).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1), 1048576);
      localInputStream = readFileOrAsciiString(paramString2, "publicKeyFileName");
      localBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramString3), 1048576);
      paramString1 = verifyAndExtract(localBufferedInputStream, localInputStream, localBufferedOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localBufferedOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString3)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public SignatureCheckResult verifyAndExtract(File paramFile1, File paramFile2, File paramFile3)
    throws PGPException, FileIsEncryptedException, IOException
  {
    return verifyAndExtract(paramFile1.getAbsolutePath(), paramFile2.getAbsolutePath(), paramFile3.getAbsolutePath());
  }
  
  public SignatureCheckResult verifyAndExtract(File paramFile1, KeyStore paramKeyStore, File paramFile2)
    throws PGPException, FileIsEncryptedException, IOException
  {
    return verifyAndExtract(paramFile1.getAbsolutePath(), paramKeyStore, paramFile2.getAbsolutePath());
  }
  
  public SignatureCheckResult verifyAndExtract(String paramString1, KeyStore paramKeyStore, String paramString2)
    throws PGPException, FileIsEncryptedException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    FileOutputStream localFileOutputStream = null;
    a("Signature verification of file {0}", paramString1);
    a("Extracting to {0}", new File(paramString2).getAbsolutePath());
    int n = 0;
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1));
      localFileOutputStream = new FileOutputStream(paramString2);
      paramString1 = verifyAndExtract(localBufferedInputStream, paramKeyStore, localFileOutputStream);
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString2)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  /**
   * @deprecated
   */
  public boolean verifyStream(InputStream paramInputStream1, InputStream paramInputStream2)
    throws PGPException, FileIsEncryptedException, IOException
  {
    paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1);
    return verifyStream(paramInputStream1, paramInputStream2, new DummyStream());
  }
  
  /**
   * @deprecated
   */
  public boolean verifyStream(InputStream paramInputStream1, InputStream paramInputStream2, OutputStream paramOutputStream)
    throws PGPException, FileIsEncryptedException, IOException
  {
    if ((((paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1)) instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream1).isClearText())) {
      return (paramInputStream1 = new PGPLib.1(this)).b((ArmoredInputStream)localObject, null, paramInputStream2, paramOutputStream) == SignatureCheckResult.SignatureVerified;
    }
    Object localObject = new PGPObjectFactory2(paramInputStream1);
    try
    {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    catch (IOException localIOException)
    {
      throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
    }
    if ((paramInputStream1 instanceof PGPMarker)) {
      paramInputStream1 = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream1 instanceof PGPEncryptedDataList)) {
      throw new FileIsEncryptedException("This file is encrypted. Use <decryptAndVerify> or <decrypt> to open it.");
    }
    if ((paramInputStream1 instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream1, true, localA, null, paramInputStream2, paramOutputStream);
    } else if ((paramInputStream1 instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream2, paramOutputStream, localA);
    } else if ((paramInputStream1 instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream1, (PGPObjectFactory)localObject, null, paramInputStream2, paramOutputStream, localA);
    } else if ((paramInputStream1 instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream1, null, paramOutputStream);
    } else {
      throw new PGPException("Unknown message format: " + paramInputStream1.getClass());
    }
    return a == SignatureCheckResult.SignatureVerified;
  }
  
  /**
   * @deprecated
   */
  public boolean verifyStream(InputStream paramInputStream, KeyStore paramKeyStore, OutputStream paramOutputStream)
    throws PGPException, FileIsEncryptedException, IOException
  {
    Object localObject;
    if ((((paramInputStream = PGPUtil.getDecoderStream(paramInputStream)) instanceof ArmoredInputStream)) && ((localObject = (ArmoredInputStream)paramInputStream).isClearText()))
    {
      paramInputStream = new PGPLib.1(this);
      try
      {
        return paramInputStream.a((ArmoredInputStream)localObject, paramKeyStore, null, paramOutputStream);
      }
      catch (SignatureException localSignatureException)
      {
        return false;
      }
    }
    if (((paramInputStream = (localObject = new PGPObjectFactory2(paramInputStream)).nextObject()) instanceof PGPMarker)) {
      paramInputStream = ((PGPObjectFactory2)localObject).nextObject();
    }
    PGPLib.a localA = new PGPLib.a(this, (byte)0);
    if ((paramInputStream instanceof PGPEncryptedDataList)) {
      throw new FileIsEncryptedException("This file is encrypted. Use <decryptAndVerify> or <decrypt> to open it.");
    }
    if ((paramInputStream instanceof PGPCompressedData)) {
      a((PGPCompressedData)paramInputStream, true, localA, paramKeyStore, null, paramOutputStream);
    } else if ((paramInputStream instanceof PGPOnePassSignatureList)) {
      a((PGPOnePassSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, paramOutputStream, localA);
    } else if ((paramInputStream instanceof PGPSignatureList)) {
      a((PGPSignatureList)paramInputStream, (PGPObjectFactory)localObject, paramKeyStore, null, paramOutputStream, localA);
    } else if ((paramInputStream instanceof PGPLiteralData)) {
      a((PGPLiteralData)paramInputStream, null, paramOutputStream);
    } else {
      throw new NonPGPDataException("Unknown message format: " + paramInputStream.getClass().getName());
    }
    return a == SignatureCheckResult.SignatureVerified;
  }
  
  /**
   * @deprecated
   */
  public boolean verifyString(String paramString1, String paramString2, StringBuffer paramStringBuffer)
    throws IOException, PGPException, FileIsEncryptedException
  {
    return verifyString(paramString1, paramString2, paramStringBuffer, "UTF-8");
  }
  
  /**
   * @deprecated
   */
  public boolean verifyString(String paramString1, String paramString2, StringBuffer paramStringBuffer, String paramString3)
    throws IOException, PGPException, FileIsEncryptedException
  {
    if (paramStringBuffer == null) {
      throw new IllegalArgumentException("The decryptedString parameter cannot be null");
    }
    ByteArrayInputStream localByteArrayInputStream = null;
    InputStream localInputStream = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes(paramString3));
      localInputStream = readFileOrAsciiString(paramString2, "publicKeyFileName");
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      paramString1 = verifyStream(localByteArrayInputStream, localInputStream, localDirectByteArrayOutputStream);
      paramStringBuffer.setLength(0);
      paramStringBuffer.append(new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString3));
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyString(String paramString1, String paramString2, String paramString3, String paramString4, StringBuffer paramStringBuffer)
    throws IOException, PGPException, FileIsEncryptedException
  {
    return decryptAndVerifyString(paramString1, paramString2, paramString3, paramString4, paramStringBuffer, "UTF-8");
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyString(String paramString1, InputStream paramInputStream1, String paramString2, InputStream paramInputStream2, StringBuffer paramStringBuffer, String paramString3)
    throws IOException, PGPException
  {
    if (paramStringBuffer == null) {
      throw new IllegalArgumentException("The decryptedString parameter cannot be null");
    }
    ByteArrayInputStream localByteArrayInputStream = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes("ASCII"));
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      paramString1 = decryptAndVerifyStream(localByteArrayInputStream, paramInputStream1, paramString2, paramInputStream2, localDirectByteArrayOutputStream);
      paramStringBuffer.setLength(0);
      paramStringBuffer.append(new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString3));
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyString(String paramString1, String paramString2, String paramString3, String paramString4, StringBuffer paramStringBuffer, String paramString5)
    throws IOException, PGPException
  {
    if (paramStringBuffer == null) {
      throw new IllegalArgumentException("The decryptedString parameter cannot be null");
    }
    ByteArrayInputStream localByteArrayInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes("ASCII"));
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFileName");
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      paramString1 = decryptAndVerifyStream(localByteArrayInputStream, localInputStream1, paramString3, localInputStream2, localDirectByteArrayOutputStream);
      paramStringBuffer.setLength(0);
      paramStringBuffer.append(new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString5));
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  public SignatureCheckResult decryptAndVerify(String paramString1, String paramString2, String paramString3, String paramString4, StringBuffer paramStringBuffer)
    throws IOException, PGPException, FileIsEncryptedException
  {
    return decryptAndVerify(paramString1, paramString2, paramString3, paramString4, paramStringBuffer, "UTF-8");
  }
  
  public SignatureCheckResult decryptAndVerify(String paramString1, String paramString2, String paramString3, String paramString4, StringBuffer paramStringBuffer, String paramString5)
    throws IOException, PGPException
  {
    if (paramStringBuffer == null) {
      throw new IllegalArgumentException("The decryptedString parameter cannot be null");
    }
    ByteArrayInputStream localByteArrayInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = null;
    try
    {
      localByteArrayInputStream = new ByteArrayInputStream(paramString1.getBytes("ASCII"));
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFileName");
      localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
      paramString1 = decryptAndVerify(localByteArrayInputStream, localInputStream1, paramString3, localInputStream2, localDirectByteArrayOutputStream);
      paramStringBuffer.setLength(0);
      paramStringBuffer.append(new String(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size(), paramString5));
      paramString1 = paramString1;
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localByteArrayInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localDirectByteArrayOutputStream);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyFile(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    a("Decrypting and verifying file {0}", new File(paramString1).getAbsolutePath());
    a("Extracting to {0}", new File(paramString3).getAbsolutePath());
    FileInputStream localFileInputStream = null;
    FileOutputStream localFileOutputStream = null;
    InputStream localInputStream = null;
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localFileOutputStream = new FileOutputStream(paramString3);
      localInputStream = PGPUtil.getDecoderStream(localFileInputStream);
      Object localObject;
      if (((localObject = (paramString1 = new PGPObjectFactory2(localInputStream)).nextObject()) instanceof PGPMarker)) {
        localObject = paramString1.nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject instanceof PGPEncryptedDataList))
      {
        paramString1 = (PGPEncryptedDataList)localObject;
        a(paramString1, true, localA, paramKeyStore, null, paramString2, null, localFileOutputStream);
      }
      else if ((localObject instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject, true, localA, paramKeyStore, null, localFileOutputStream);
      }
      else
      {
        if (localObject == null) {
          throw new NonPGPDataException("The supplied data is not a valid OpenPGP message");
        }
        throw new PGPException("Unknown message format: " + localObject);
      }
      paramString1 = a == SignatureCheckResult.SignatureVerified ? 1 : 0;
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localFileOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString3)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  public SignatureCheckResult decryptAndVerify(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying file {0}", paramString1);
    a("Extracting to {0}", new File(paramString5).getAbsolutePath());
    FileInputStream localFileInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFile");
      localFileOutputStream = new FileOutputStream(paramString5);
      paramString1 = decryptAndVerify(localFileInputStream, localInputStream1, paramString3, localInputStream2, localFileOutputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localFileOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString5)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  public SignatureCheckResult decryptAndVerify(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    a("Decrypting and verifying file {0}", new File(paramString1).getAbsolutePath());
    a("Extracting to {0}", new File(paramString3).getAbsolutePath());
    FileInputStream localFileInputStream = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localFileOutputStream = new FileOutputStream(paramString3);
      paramString1 = decryptAndVerify(localFileInputStream, paramKeyStore, paramString2, localFileOutputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(null);
      IOUtil.closeStream(localFileOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(null);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramKeyStore = new File(paramString3)).exists())) {
        paramKeyStore.delete();
      }
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyFileTo(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    FileInputStream localFileInputStream = null;
    InputStream localInputStream = null;
    a("Decrypting and verifying file {0}", new File(paramString1).getAbsolutePath());
    a("Extracting to {0}", new File(paramString3).getAbsolutePath());
    try
    {
      localInputStream = PGPUtil.getDecoderStream(localFileInputStream = new FileInputStream(paramString1));
      Object localObject1;
      Object localObject2;
      if (((localObject2 = (localObject1 = new PGPObjectFactory2(localInputStream)).nextObject()) instanceof PGPMarker)) {
        localObject2 = ((PGPObjectFactory2)localObject1).nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject2 instanceof PGPEncryptedDataList))
      {
        localObject1 = (PGPEncryptedDataList)localObject2;
        a((PGPEncryptedDataList)localObject1, true, localA, paramKeyStore, null, paramString2, null, paramString3, paramString1);
      }
      else if ((localObject2 instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject2, true, localA, paramKeyStore, null, paramString3, paramString1);
      }
      else if ((localObject2 instanceof PGPOnePassSignatureList))
      {
        a((PGPOnePassSignatureList)localObject2, (PGPObjectFactory)localObject1, paramKeyStore, null, paramString3, paramString1, localA);
      }
      else if ((localObject2 instanceof PGPSignatureList))
      {
        a((PGPSignatureList)localObject2, (PGPObjectFactory)localObject1, paramKeyStore, null, paramString3, paramString1, localA);
      }
      else if ((localObject2 instanceof PGPLiteralData))
      {
        a((PGPLiteralData)localObject2, null, paramString3, paramString1);
      }
      else
      {
        throw new NonPGPDataException("The supplied data is not a valid OpenPGP message");
      }
      paramString1 = a == SignatureCheckResult.SignatureVerified ? 1 : 0;
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public SignatureCheckResult decryptAndVerifyTo(String paramString1, KeyStore paramKeyStore, String paramString2, String paramString3)
    throws PGPException, IOException
  {
    BufferedInputStream localBufferedInputStream = null;
    a("Decrypting and verifying file {0}", new File(paramString1).getAbsolutePath());
    a("Extracting to {0}", new File(paramString3).getAbsolutePath());
    try
    {
      localBufferedInputStream = new BufferedInputStream(new FileInputStream(paramString1));
      paramString1 = decryptAndVerifyTo(localBufferedInputStream, paramKeyStore, paramString2, paramString3);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localBufferedInputStream);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyStream(InputStream paramInputStream, KeyStore paramKeyStore, String paramString, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      if ((((localInputStream = PGPUtil.getDecoderStream(paramInputStream)) instanceof ArmoredInputStream)) && ((paramInputStream = (ArmoredInputStream)localInputStream).isClearText()))
      {
        a("Clear text signed data found");
        PGPLib.1 local1 = new PGPLib.1(this);
        try
        {
          boolean bool = local1.a(paramInputStream, paramKeyStore, null, paramOutputStream);
          return bool;
        }
        catch (SignatureException localSignatureException)
        {
          a("Signature exception: " + localSignatureException);
          return false;
        }
      }
      paramInputStream = new PGPObjectFactory2(localInputStream);
      Object localObject;
      try
      {
        localObject = paramInputStream.nextObject();
      }
      catch (IOException localIOException)
      {
        throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
      }
      if ((localObject instanceof PGPMarker))
      {
        a("Skipping PGP marker.");
        localObject = paramInputStream.nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject instanceof PGPEncryptedDataList))
      {
        localObject = (PGPEncryptedDataList)localObject;
        a((PGPEncryptedDataList)localObject, true, localA, paramKeyStore, null, paramString, null, paramOutputStream);
      }
      else if ((localObject instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject, true, localA, paramKeyStore, null, paramOutputStream);
      }
      else if ((localObject instanceof PGPOnePassSignatureList))
      {
        a((PGPOnePassSignatureList)localObject, paramInputStream, paramKeyStore, null, paramOutputStream, localA);
      }
      else if ((localObject instanceof PGPSignatureList))
      {
        a((PGPSignatureList)localObject, paramInputStream, paramKeyStore, null, paramOutputStream, localA);
      }
      else if ((localObject instanceof PGPLiteralData))
      {
        a((PGPLiteralData)localObject, null, paramOutputStream);
      }
      else
      {
        throw new NonPGPDataException("Unknown message format: " + localObject);
      }
      paramInputStream = a == SignatureCheckResult.SignatureVerified ? 1 : 0;
      return paramInputStream;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public SignatureCheckResult decryptAndVerify(InputStream paramInputStream, KeyStore paramKeyStore, String paramString, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    InputStream localInputStream = null;
    try
    {
      Object localObject;
      if ((((localInputStream = PGPUtil.getDecoderStream(paramInputStream)) instanceof ArmoredInputStream)) && ((paramInputStream = (ArmoredInputStream)localInputStream).isClearText()))
      {
        a("Clear text signed data found");
        localObject = (localObject = new PGPLib.1(this)).b(paramInputStream, paramKeyStore, null, paramOutputStream);
        return localObject;
      }
      paramInputStream = new PGPObjectFactory2(localInputStream);
      try
      {
        localObject = paramInputStream.nextObject();
      }
      catch (IOException localIOException)
      {
        throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
      }
      if ((localObject instanceof PGPMarker))
      {
        a("Skipping PGP marker.");
        localObject = paramInputStream.nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject instanceof PGPEncryptedDataList))
      {
        localObject = (PGPEncryptedDataList)localObject;
        a((PGPEncryptedDataList)localObject, true, localA, paramKeyStore, null, paramString, null, paramOutputStream);
      }
      else if ((localObject instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject, true, localA, paramKeyStore, null, paramOutputStream);
      }
      else if ((localObject instanceof PGPOnePassSignatureList))
      {
        a((PGPOnePassSignatureList)localObject, paramInputStream, paramKeyStore, null, paramOutputStream, localA);
      }
      else if ((localObject instanceof PGPSignatureList))
      {
        a((PGPSignatureList)localObject, paramInputStream, paramKeyStore, null, paramOutputStream, localA);
      }
      else if ((localObject instanceof PGPLiteralData))
      {
        a((PGPLiteralData)localObject, null, paramOutputStream);
      }
      else
      {
        throw new NonPGPDataException("Unknown message format: " + localObject);
      }
      paramInputStream = a;
      return paramInputStream;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyFile(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying file {0}", paramString1);
    a("Extracting to {0}", new File(paramString5).getAbsolutePath());
    FileInputStream localFileInputStream = null;
    InputStream localInputStream1 = null;
    InputStream localInputStream2 = null;
    FileOutputStream localFileOutputStream = null;
    int n = 0;
    try
    {
      localFileInputStream = new FileInputStream(paramString1);
      localInputStream1 = readFileOrAsciiString(paramString2, "privateKeyFileName");
      localInputStream2 = readFileOrAsciiString(paramString4, "publicKeyFile");
      localFileOutputStream = new FileOutputStream(paramString5);
      paramString1 = decryptAndVerifyStream(localFileInputStream, localInputStream1, paramString3, localInputStream2, localFileOutputStream);
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localFileOutputStream);
      return paramString1;
    }
    catch (PGPException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    catch (IOException paramString1)
    {
      n = 1;
      throw paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream);
      IOUtil.closeStream(localInputStream1);
      IOUtil.closeStream(localInputStream2);
      IOUtil.closeStream(localFileOutputStream);
      if ((n != 0) && ((paramString2 = new File(paramString5)).exists())) {
        paramString2.delete();
      }
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyFileTo(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying file {0}", paramString1);
    a("Extracting to {0}", new File(paramString5).getAbsolutePath());
    FileInputStream localFileInputStream1 = null;
    FileInputStream localFileInputStream2 = null;
    FileInputStream localFileInputStream3 = null;
    try
    {
      localFileInputStream1 = new FileInputStream(paramString1);
      localFileInputStream2 = new FileInputStream(paramString2);
      localFileInputStream3 = new FileInputStream(paramString4);
      paramString1 = decryptAndVerifyStreamTo(localFileInputStream1, localFileInputStream2, paramString3, localFileInputStream3, paramString5);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream1);
      IOUtil.closeStream(localFileInputStream2);
      IOUtil.closeStream(localFileInputStream3);
    }
  }
  
  public SignatureCheckResult decryptAndVerifyTo(String paramString1, String paramString2, String paramString3, String paramString4, String paramString5)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying file {0}", paramString1);
    a("Extracting to {0}", new File(paramString5).getAbsolutePath());
    FileInputStream localFileInputStream1 = null;
    FileInputStream localFileInputStream2 = null;
    FileInputStream localFileInputStream3 = null;
    try
    {
      localFileInputStream1 = new FileInputStream(paramString1);
      localFileInputStream2 = new FileInputStream(paramString2);
      localFileInputStream3 = new FileInputStream(paramString4);
      paramString1 = decryptAndVerifyTo(localFileInputStream1, localFileInputStream2, paramString3, localFileInputStream3, paramString5);
      return paramString1;
    }
    finally
    {
      IOUtil.closeStream(localFileInputStream1);
      IOUtil.closeStream(localFileInputStream2);
      IOUtil.closeStream(localFileInputStream3);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyStream(InputStream paramInputStream1, InputStream paramInputStream2, String paramString, InputStream paramInputStream3, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    Object localObject1;
    if ((((paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1)) instanceof ArmoredInputStream)) && ((localObject1 = (ArmoredInputStream)paramInputStream1).isClearText()))
    {
      a("Clear text signed data found");
      PGPLib.1 local1 = new PGPLib.1(this);
      try
      {
        return local1.a((ArmoredInputStream)localObject1, null, paramInputStream3, paramOutputStream);
      }
      catch (SignatureException localSignatureException)
      {
        a("Signature exception: " + localSignatureException);
        return false;
      }
    }
    try
    {
      localObject1 = new PGPObjectFactory2(paramInputStream1);
      Object localObject2;
      try
      {
        localObject2 = ((PGPObjectFactory2)localObject1).nextObject();
      }
      catch (IOException localIOException)
      {
        throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
      }
      if ((localObject2 instanceof PGPMarker))
      {
        a("Skipping marker packet.");
        localObject2 = ((PGPObjectFactory2)localObject1).nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject2 instanceof PGPEncryptedDataList))
      {
        localObject2 = (PGPEncryptedDataList)localObject2;
        a((PGPEncryptedDataList)localObject2, true, localA, null, paramInputStream2, paramString, paramInputStream3, paramOutputStream);
      }
      else if ((localObject2 instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject2, true, localA, null, paramInputStream3, paramOutputStream);
      }
      else if ((localObject2 instanceof PGPOnePassSignatureList))
      {
        a((PGPOnePassSignatureList)localObject2, (PGPObjectFactory)localObject1, null, paramInputStream3, paramOutputStream, localA);
      }
      else if ((localObject2 instanceof PGPSignatureList))
      {
        a((PGPSignatureList)localObject2, (PGPObjectFactory)localObject1, null, paramInputStream3, paramOutputStream, localA);
      }
      else if ((localObject2 instanceof PGPLiteralData))
      {
        a((PGPLiteralData)localObject2, null, paramOutputStream);
      }
      else
      {
        throw new NonPGPDataException("Unknown message format: " + localObject2);
      }
      paramInputStream2 = a == SignatureCheckResult.SignatureVerified ? 1 : 0;
      return paramInputStream2;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      a("PGPException " + localPGPException);
      throw IOUtil.newPGPException(localPGPException);
    }
    finally
    {
      IOUtil.closeStream(paramInputStream1);
    }
  }
  
  public SignatureCheckResult decryptAndVerify(InputStream paramInputStream1, InputStream paramInputStream2, String paramString, InputStream paramInputStream3, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    Object localObject1;
    Object localObject2;
    if ((((paramInputStream1 = PGPUtil.getDecoderStream(paramInputStream1)) instanceof ArmoredInputStream)) && ((localObject1 = (ArmoredInputStream)paramInputStream1).isClearText()))
    {
      a("Clear text signed data found");
      return (localObject2 = new PGPLib.1(this)).b((ArmoredInputStream)localObject1, null, paramInputStream3, paramOutputStream);
    }
    try
    {
      localObject1 = new PGPObjectFactory2(paramInputStream1);
      try
      {
        localObject2 = ((PGPObjectFactory2)localObject1).nextObject();
      }
      catch (IOException localIOException)
      {
        throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
      }
      if ((localObject2 instanceof PGPMarker))
      {
        a("Skipping marker packet.");
        localObject2 = ((PGPObjectFactory2)localObject1).nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject2 instanceof PGPEncryptedDataList))
      {
        localObject2 = (PGPEncryptedDataList)localObject2;
        a((PGPEncryptedDataList)localObject2, true, localA, null, paramInputStream2, paramString, paramInputStream3, paramOutputStream);
      }
      else if ((localObject2 instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject2, true, localA, null, paramInputStream3, paramOutputStream);
      }
      else if ((localObject2 instanceof PGPOnePassSignatureList))
      {
        a((PGPOnePassSignatureList)localObject2, (PGPObjectFactory)localObject1, null, paramInputStream3, paramOutputStream, localA);
      }
      else if ((localObject2 instanceof PGPSignatureList))
      {
        a((PGPSignatureList)localObject2, (PGPObjectFactory)localObject1, null, paramInputStream3, paramOutputStream, localA);
      }
      else if ((localObject2 instanceof PGPLiteralData))
      {
        a((PGPLiteralData)localObject2, null, paramOutputStream);
      }
      else
      {
        throw new NonPGPDataException("Unknown message format: " + localObject2);
      }
      paramInputStream2 = a;
      return paramInputStream2;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      a("PGPException " + localPGPException);
      throw IOUtil.newPGPException(localPGPException);
    }
    finally
    {
      IOUtil.closeStream(paramInputStream1);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyStreamTo(InputStream paramInputStream1, InputStream paramInputStream2, String paramString1, InputStream paramInputStream3, String paramString2)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying of stream data to {0}", new File(paramString2).getAbsolutePath());
    InputStream localInputStream = null;
    try
    {
      localInputStream = PGPUtil.getDecoderStream(paramInputStream1);
      paramInputStream1 = new PGPObjectFactory2(localInputStream);
      Object localObject;
      try
      {
        localObject = paramInputStream1.nextObject();
      }
      catch (IOException localIOException)
      {
        throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
      }
      if ((localObject instanceof PGPMarker))
      {
        a("Skipping marker packet.");
        localObject = paramInputStream1.nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject instanceof PGPEncryptedDataList))
      {
        paramInputStream1 = (PGPEncryptedDataList)localObject;
        a(paramInputStream1, true, localA, null, paramInputStream2, paramString1, paramInputStream3, paramString2, null);
      }
      else if ((localObject instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject, true, localA, null, paramInputStream3, paramString2, null);
      }
      else if ((localObject instanceof PGPOnePassSignatureList))
      {
        a((PGPOnePassSignatureList)localObject, paramInputStream1, null, paramInputStream3, paramString2, null, localA);
      }
      else if ((localObject instanceof PGPSignatureList))
      {
        a((PGPSignatureList)localObject, paramInputStream1, null, paramInputStream3, paramString2, null, localA);
      }
      else if ((localObject instanceof PGPLiteralData))
      {
        a((PGPLiteralData)localObject, null, paramString2, null);
      }
      else
      {
        throw new NonPGPDataException("Unknown message format: " + localObject);
      }
      paramInputStream1 = a == SignatureCheckResult.SignatureVerified ? 1 : 0;
      return paramInputStream1;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public SignatureCheckResult decryptAndVerifyTo(InputStream paramInputStream1, InputStream paramInputStream2, String paramString1, InputStream paramInputStream3, String paramString2)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying of stream data to {0}", new File(paramString2).getAbsolutePath());
    InputStream localInputStream = null;
    try
    {
      localInputStream = PGPUtil.getDecoderStream(paramInputStream1);
      paramInputStream1 = new PGPObjectFactory2(localInputStream);
      Object localObject;
      try
      {
        localObject = paramInputStream1.nextObject();
      }
      catch (IOException localIOException)
      {
        throw new NonPGPDataException("The supplied data is not a valid OpenPGP message", localIOException);
      }
      if ((localObject instanceof PGPMarker))
      {
        a("Skipping marker packet.");
        localObject = paramInputStream1.nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject instanceof PGPEncryptedDataList))
      {
        paramInputStream1 = (PGPEncryptedDataList)localObject;
        a(paramInputStream1, true, localA, null, paramInputStream2, paramString1, paramInputStream3, paramString2, null);
      }
      else if ((localObject instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject, true, localA, null, paramInputStream3, paramString2, null);
      }
      else if ((localObject instanceof PGPOnePassSignatureList))
      {
        a((PGPOnePassSignatureList)localObject, paramInputStream1, null, paramInputStream3, paramString2, null, localA);
      }
      else if ((localObject instanceof PGPSignatureList))
      {
        a((PGPSignatureList)localObject, paramInputStream1, null, paramInputStream3, paramString2, null, localA);
      }
      else if ((localObject instanceof PGPLiteralData))
      {
        a((PGPLiteralData)localObject, null, paramString2, null);
      }
      else
      {
        throw new NonPGPDataException("Unknown message format: " + localObject);
      }
      paramInputStream1 = a;
      return paramInputStream1;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  /**
   * @deprecated
   */
  public boolean decryptAndVerifyStreamTo(InputStream paramInputStream, KeyStore paramKeyStore, String paramString1, String paramString2)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying of stream data to {0}", new File(paramString2).getAbsolutePath());
    InputStream localInputStream = null;
    try
    {
      localInputStream = PGPUtil.getDecoderStream(paramInputStream);
      Object localObject;
      if (((localObject = (paramInputStream = new PGPObjectFactory2(localInputStream)).nextObject()) instanceof PGPMarker)) {
        localObject = paramInputStream.nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject instanceof PGPEncryptedDataList))
      {
        paramInputStream = (PGPEncryptedDataList)localObject;
        a(paramInputStream, true, localA, paramKeyStore, null, paramString1, null, paramString2, null);
      }
      else if ((localObject instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject, true, localA, paramKeyStore, null, paramString2, null);
      }
      else
      {
        if (localObject == null) {
          throw new NonPGPDataException("The supplied data is not a valid OpenPGP message");
        }
        throw new lw.bouncycastle.openpgp.PGPException("Unknown message format: " + localObject);
      }
      paramInputStream = a == SignatureCheckResult.SignatureVerified ? 1 : 0;
      return paramInputStream;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  public SignatureCheckResult decryptAndVerifyTo(InputStream paramInputStream, KeyStore paramKeyStore, String paramString1, String paramString2)
    throws PGPException, IOException
  {
    a("Decrypting and signature verifying of stream data to {0}", new File(paramString2).getAbsolutePath());
    InputStream localInputStream = null;
    try
    {
      localInputStream = PGPUtil.getDecoderStream(paramInputStream);
      Object localObject;
      if (((localObject = (paramInputStream = new PGPObjectFactory2(localInputStream)).nextObject()) instanceof PGPMarker)) {
        localObject = paramInputStream.nextObject();
      }
      PGPLib.a localA = new PGPLib.a(this, (byte)0);
      if ((localObject instanceof PGPEncryptedDataList))
      {
        paramInputStream = (PGPEncryptedDataList)localObject;
        a(paramInputStream, true, localA, paramKeyStore, null, paramString1, null, paramString2, null);
      }
      else if ((localObject instanceof PGPCompressedData))
      {
        a((PGPCompressedData)localObject, true, localA, paramKeyStore, null, paramString2, null);
      }
      else
      {
        if (localObject == null) {
          throw new NonPGPDataException("The supplied data is not a valid OpenPGP message");
        }
        throw new lw.bouncycastle.openpgp.PGPException("Unknown message format: " + localObject);
      }
      paramInputStream = a;
      return paramInputStream;
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException) {}finally
    {
      IOUtil.closeStream(localInputStream);
    }
  }
  
  /* Error */
  private void a(InputStream paramInputStream, String paramString, PGPPublicKey[] paramArrayOfPGPPublicKey, OutputStream paramOutputStream, Date paramDate, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3)
    throws PGPException, IOException
  {
    // Byte code:
    //   0: aload_0
    //   1: getfield 278	com/didisoft/pgp/PGPLib:k	Z
    //   4: ifeq +15 -> 19
    //   7: aload_0
    //   8: aload_1
    //   9: aload_2
    //   10: aload_3
    //   11: aload 4
    //   13: iload 6
    //   15: invokespecial 316	com/didisoft/pgp/PGPLib:a	(Ljava/io/InputStream;Ljava/lang/String;[Llw/bouncycastle/openpgp/PGPPublicKey;Ljava/io/OutputStream;Z)V
    //   18: return
    //   19: aload 4
    //   21: instanceof 193
    //   24: ifne +16 -> 40
    //   27: new 193	java/io/BufferedOutputStream
    //   30: dup
    //   31: aload 4
    //   33: ldc 3
    //   35: invokespecial 489	java/io/BufferedOutputStream:<init>	(Ljava/io/OutputStream;I)V
    //   38: astore 4
    //   40: iload 6
    //   42: ifeq +24 -> 66
    //   45: aload 4
    //   47: astore 4
    //   49: new 229	lw/bouncycastle/bcpg/ArmoredOutputStream
    //   52: dup
    //   53: aload 4
    //   55: invokespecial 572	lw/bouncycastle/bcpg/ArmoredOutputStream:<init>	(Ljava/io/OutputStream;)V
    //   58: astore 4
    //   60: aload_0
    //   61: aload 4
    //   63: invokespecial 318	com/didisoft/pgp/PGPLib:a	(Ljava/io/OutputStream;)V
    //   66: aload_0
    //   67: getfield 271	com/didisoft/pgp/PGPLib:d	Ljava/lang/String;
    //   70: invokestatic 297	com/didisoft/pgp/KeyStore:b	(Ljava/lang/String;)I
    //   73: istore 9
    //   75: aload_0
    //   76: getfield 270	com/didisoft/pgp/PGPLib:c	Ljava/lang/String;
    //   79: invokestatic 299	com/didisoft/pgp/KeyStore:c	(Ljava/lang/String;)I
    //   82: istore 10
    //   84: aload_3
    //   85: arraylength
    //   86: iconst_1
    //   87: if_icmpne +43 -> 130
    //   90: aload_0
    //   91: aload_3
    //   92: iconst_0
    //   93: aaload
    //   94: invokespecial 397	com/didisoft/pgp/PGPLib:h	(Llw/bouncycastle/openpgp/PGPPublicKey;)I
    //   97: istore 9
    //   99: aload_0
    //   100: aload_3
    //   101: iconst_0
    //   102: aaload
    //   103: invokespecial 393	com/didisoft/pgp/PGPLib:f	(Llw/bouncycastle/openpgp/PGPPublicKey;)I
    //   106: istore 10
    //   108: aload_0
    //   109: ldc 54
    //   111: iload 10
    //   113: invokestatic 298	com/didisoft/pgp/KeyStore:c	(I)Ljava/lang/String;
    //   116: invokespecial 321	com/didisoft/pgp/PGPLib:a	(Ljava/lang/String;Ljava/lang/String;)V
    //   119: aload_0
    //   120: ldc 28
    //   122: iload 9
    //   124: invokestatic 292	com/didisoft/pgp/KeyStore:a	(I)Ljava/lang/String;
    //   127: invokespecial 321	com/didisoft/pgp/PGPLib:a	(Ljava/lang/String;Ljava/lang/String;)V
    //   130: iload 8
    //   132: ifeq +23 -> 155
    //   135: new 230	lw/bouncycastle/bcpg/BCPGOutputStream
    //   138: dup
    //   139: aload 4
    //   141: invokespecial 574	lw/bouncycastle/bcpg/BCPGOutputStream:<init>	(Ljava/io/OutputStream;)V
    //   144: dup
    //   145: astore 8
    //   147: invokestatic 322	com/didisoft/pgp/PGPLib:a	(Llw/bouncycastle/bcpg/BCPGOutputStream;)V
    //   150: aload 8
    //   152: invokevirtual 575	lw/bouncycastle/bcpg/BCPGOutputStream:flush	()V
    //   155: new 234	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator
    //   158: dup
    //   159: aload_0
    //   160: getfield 268	com/didisoft/pgp/PGPLib:a	Lcom/didisoft/pgp/bc/BCFactory;
    //   163: iload 10
    //   165: iload 7
    //   167: invokestatic 468	com/didisoft/pgp/bc/IOUtil:getSecureRandom	()Ljava/security/SecureRandom;
    //   170: invokevirtual 445	com/didisoft/pgp/bc/BCFactory:CreatePGPDataEncryptorBuilder	(IZLjava/security/SecureRandom;)Llw/bouncycastle/openpgp/operator/PGPDataEncryptorBuilder;
    //   173: invokespecial 583	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:<init>	(Llw/bouncycastle/openpgp/operator/PGPDataEncryptorBuilder;)V
    //   176: astore 8
    //   178: iconst_0
    //   179: istore 7
    //   181: iload 7
    //   183: aload_3
    //   184: arraylength
    //   185: if_icmpge +41 -> 226
    //   188: aload_0
    //   189: ldc 55
    //   191: aload_3
    //   192: iload 7
    //   194: aaload
    //   195: invokevirtual 613	lw/bouncycastle/openpgp/PGPPublicKey:getKeyID	()J
    //   198: invokestatic 290	com/didisoft/pgp/KeyPairInformation:keyId2Hex	(J)Ljava/lang/String;
    //   201: invokespecial 321	com/didisoft/pgp/PGPLib:a	(Ljava/lang/String;Ljava/lang/String;)V
    //   204: aload 8
    //   206: aload_0
    //   207: getfield 268	com/didisoft/pgp/PGPLib:a	Lcom/didisoft/pgp/bc/BCFactory;
    //   210: aload_3
    //   211: iload 7
    //   213: aaload
    //   214: invokevirtual 451	com/didisoft/pgp/bc/BCFactory:CreatePublicKeyKeyEncryptionMethodGenerator	(Llw/bouncycastle/openpgp/PGPPublicKey;)Llw/bouncycastle/openpgp/operator/PublicKeyKeyEncryptionMethodGenerator;
    //   217: invokevirtual 584	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:addMethod	(Llw/bouncycastle/openpgp/operator/PGPKeyEncryptionMethodGenerator;)V
    //   220: iinc 7 1
    //   223: goto -42 -> 181
    //   226: aload 8
    //   228: aload 4
    //   230: ldc 3
    //   232: newarray byte
    //   234: invokevirtual 587	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:open	(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;
    //   237: astore_3
    //   238: goto +10 -> 248
    //   241: dup
    //   242: astore 7
    //   244: invokestatic 469	com/didisoft/pgp/bc/IOUtil:newPGPException	(Llw/bouncycastle/openpgp/PGPException;)Lcom/didisoft/pgp/PGPException;
    //   247: athrow
    //   248: new 232	lw/bouncycastle/openpgp/PGPCompressedDataGenerator
    //   251: dup
    //   252: iload 9
    //   254: invokespecial 578	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:<init>	(I)V
    //   257: astore 7
    //   259: new 238	lw/bouncycastle/openpgp/PGPLiteralDataGenerator
    //   262: dup
    //   263: invokespecial 594	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:<init>	()V
    //   266: astore 8
    //   268: aconst_null
    //   269: astore 10
    //   271: iload 9
    //   273: ifne +31 -> 304
    //   276: aload 8
    //   278: aload_3
    //   279: aload_0
    //   280: invokevirtual 395	com/didisoft/pgp/PGPLib:getContentType	()C
    //   283: aload_2
    //   284: aload 5
    //   286: ldc 3
    //   288: newarray byte
    //   290: invokevirtual 598	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:open	(Ljava/io/OutputStream;CLjava/lang/String;Ljava/util/Date;[B)Ljava/io/OutputStream;
    //   293: astore 10
    //   295: aload_1
    //   296: aload 10
    //   298: invokestatic 399	com/didisoft/pgp/PGPLib:pipeAll	(Ljava/io/InputStream;Ljava/io/OutputStream;)V
    //   301: goto +33 -> 334
    //   304: aload 8
    //   306: aload 7
    //   308: aload_3
    //   309: invokevirtual 580	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:open	(Ljava/io/OutputStream;)Ljava/io/OutputStream;
    //   312: aload_0
    //   313: invokevirtual 395	com/didisoft/pgp/PGPLib:getContentType	()C
    //   316: aload_2
    //   317: aload 5
    //   319: ldc 3
    //   321: newarray byte
    //   323: invokevirtual 598	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:open	(Ljava/io/OutputStream;CLjava/lang/String;Ljava/util/Date;[B)Ljava/io/OutputStream;
    //   326: astore 10
    //   328: aload_1
    //   329: aload 10
    //   331: invokestatic 399	com/didisoft/pgp/PGPLib:pipeAll	(Ljava/io/InputStream;Ljava/io/OutputStream;)V
    //   334: aload 8
    //   336: invokevirtual 596	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:close	()V
    //   339: aload 10
    //   341: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   344: aload_1
    //   345: invokestatic 466	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/InputStream;)V
    //   348: aload 7
    //   350: invokevirtual 579	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:close	()V
    //   353: goto +25 -> 378
    //   356: astore_2
    //   357: aload 8
    //   359: invokevirtual 596	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:close	()V
    //   362: aload 10
    //   364: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   367: aload_1
    //   368: invokestatic 466	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/InputStream;)V
    //   371: aload 7
    //   373: invokevirtual 579	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:close	()V
    //   376: aload_2
    //   377: athrow
    //   378: aload_3
    //   379: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   382: aload 4
    //   384: invokevirtual 513	java/io/OutputStream:flush	()V
    //   387: iload 6
    //   389: ifeq +33 -> 422
    //   392: aload 4
    //   394: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   397: goto +30 -> 427
    //   400: astore_1
    //   401: aload_3
    //   402: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   405: aload 4
    //   407: invokevirtual 513	java/io/OutputStream:flush	()V
    //   410: iload 6
    //   412: ifeq +8 -> 420
    //   415: aload 4
    //   417: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   420: aload_1
    //   421: athrow
    //   422: return
    //   423: dup
    //   424: astore 4
    //   426: athrow
    //   427: return
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	428	0	this	PGPLib
    //   0	428	1	paramInputStream	InputStream
    //   0	428	2	paramString	String
    //   0	428	3	paramArrayOfPGPPublicKey	PGPPublicKey[]
    //   0	428	4	paramOutputStream	OutputStream
    //   0	428	5	paramDate	Date
    //   0	428	6	paramBoolean1	boolean
    //   0	428	7	paramBoolean2	boolean
    //   0	428	8	paramBoolean3	boolean
    //   73	199	9	n	int
    //   82	82	10	i1	int
    //   269	94	10	localOutputStream	OutputStream
    //   241	1	12	localPGPException	lw.bouncycastle.openpgp.PGPException
    //   423	1	13	localIOException	IOException
    // Exception table:
    //   from	to	target	type
    //   178	238	241	lw/bouncycastle/openpgp/PGPException
    //   271	334	356	finally
    //   248	378	400	finally
    //   40	422	423	java/io/IOException
  }
  
  private void a(InputStream paramInputStream, String paramString, PGPPublicKey[] paramArrayOfPGPPublicKey, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, IOException
  {
    a("Encrypting in PGP 2.x compatibility mode");
    if ((paramString == null) || ("".equals(paramString.trim())))
    {
      a("No internal file name label was specified. Using {0} instead.", "_CONSOLE");
      paramString = "_CONSOLE";
    }
    paramOutputStream = paramOutputStream;
    if (paramBoolean)
    {
      a("Output is ASCII armored");
      paramOutputStream = paramOutputStream;
      paramOutputStream = new ArmoredOutputStream(paramOutputStream);
      a(paramOutputStream);
    }
    a("Cipher used is {0}", KeyStore.c(1));
    PGPEncryptedDataGenerator localPGPEncryptedDataGenerator = a.CreatePGPEncryptedDataGenerator(1, false, IOUtil.getSecureRandom(), true);
    for (int n = 0; n < paramArrayOfPGPPublicKey.length; n++)
    {
      localPGPEncryptedDataGenerator.addMethod(a.CreatePublicKeyKeyEncryptionMethodGenerator(paramArrayOfPGPPublicKey[n]));
      a("Encrypting for key Id {0}", String.valueOf(paramArrayOfPGPPublicKey[n].getKeyID()));
    }
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
    BaseLib.pipeAll(paramInputStream, localDirectByteArrayOutputStream);
    paramInputStream = new DirectByteArrayOutputStream(1048576);
    paramString = (paramArrayOfPGPPublicKey = new PGPLiteralDataGenerator(true)).open(paramInputStream, i, paramString, localDirectByteArrayOutputStream.size(), new Date());
    localDirectByteArrayOutputStream.writeTo(paramString);
    paramArrayOfPGPPublicKey.close();
    paramString.close();
    try
    {
      paramString = localPGPEncryptedDataGenerator.open(paramOutputStream, paramInputStream.size());
      paramInputStream.writeTo(paramString);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(paramInputStream = localPGPException);
    }
    IOUtil.closeStream(paramString);
    paramOutputStream.flush();
    if (paramBoolean) {
      IOUtil.closeStream(paramOutputStream);
    }
  }
  
  /* Error */
  private void b(InputStream paramInputStream, String paramString, PGPPublicKey[] paramArrayOfPGPPublicKey, OutputStream paramOutputStream, Date paramDate, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3)
    throws PGPException, IOException
  {
    // Byte code:
    //   0: iload 6
    //   2: ifeq +24 -> 26
    //   5: aload 4
    //   7: astore 4
    //   9: new 229	lw/bouncycastle/bcpg/ArmoredOutputStream
    //   12: dup
    //   13: aload 4
    //   15: invokespecial 572	lw/bouncycastle/bcpg/ArmoredOutputStream:<init>	(Ljava/io/OutputStream;)V
    //   18: astore 4
    //   20: aload_0
    //   21: aload 4
    //   23: invokespecial 318	com/didisoft/pgp/PGPLib:a	(Ljava/io/OutputStream;)V
    //   26: aload_0
    //   27: getfield 271	com/didisoft/pgp/PGPLib:d	Ljava/lang/String;
    //   30: invokestatic 297	com/didisoft/pgp/KeyStore:b	(Ljava/lang/String;)I
    //   33: istore 8
    //   35: aload_0
    //   36: getfield 270	com/didisoft/pgp/PGPLib:c	Ljava/lang/String;
    //   39: invokestatic 299	com/didisoft/pgp/KeyStore:c	(Ljava/lang/String;)I
    //   42: istore 9
    //   44: aload_3
    //   45: arraylength
    //   46: iconst_1
    //   47: if_icmpne +43 -> 90
    //   50: aload_0
    //   51: aload_3
    //   52: iconst_0
    //   53: aaload
    //   54: invokespecial 397	com/didisoft/pgp/PGPLib:h	(Llw/bouncycastle/openpgp/PGPPublicKey;)I
    //   57: istore 8
    //   59: aload_0
    //   60: aload_3
    //   61: iconst_0
    //   62: aaload
    //   63: invokespecial 393	com/didisoft/pgp/PGPLib:f	(Llw/bouncycastle/openpgp/PGPPublicKey;)I
    //   66: istore 9
    //   68: aload_0
    //   69: ldc 54
    //   71: iload 9
    //   73: invokestatic 298	com/didisoft/pgp/KeyStore:c	(I)Ljava/lang/String;
    //   76: invokespecial 321	com/didisoft/pgp/PGPLib:a	(Ljava/lang/String;Ljava/lang/String;)V
    //   79: aload_0
    //   80: ldc 28
    //   82: iload 8
    //   84: invokestatic 292	com/didisoft/pgp/KeyStore:a	(I)Ljava/lang/String;
    //   87: invokespecial 321	com/didisoft/pgp/PGPLib:a	(Ljava/lang/String;Ljava/lang/String;)V
    //   90: new 234	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator
    //   93: dup
    //   94: aload_0
    //   95: getfield 268	com/didisoft/pgp/PGPLib:a	Lcom/didisoft/pgp/bc/BCFactory;
    //   98: iload 9
    //   100: iload 7
    //   102: invokestatic 468	com/didisoft/pgp/bc/IOUtil:getSecureRandom	()Ljava/security/SecureRandom;
    //   105: invokevirtual 445	com/didisoft/pgp/bc/BCFactory:CreatePGPDataEncryptorBuilder	(IZLjava/security/SecureRandom;)Llw/bouncycastle/openpgp/operator/PGPDataEncryptorBuilder;
    //   108: invokespecial 583	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:<init>	(Llw/bouncycastle/openpgp/operator/PGPDataEncryptorBuilder;)V
    //   111: astore 7
    //   113: iconst_0
    //   114: istore 9
    //   116: iload 9
    //   118: aload_3
    //   119: arraylength
    //   120: if_icmpge +41 -> 161
    //   123: aload_0
    //   124: ldc 55
    //   126: aload_3
    //   127: iload 9
    //   129: aaload
    //   130: invokevirtual 613	lw/bouncycastle/openpgp/PGPPublicKey:getKeyID	()J
    //   133: invokestatic 290	com/didisoft/pgp/KeyPairInformation:keyId2Hex	(J)Ljava/lang/String;
    //   136: invokespecial 321	com/didisoft/pgp/PGPLib:a	(Ljava/lang/String;Ljava/lang/String;)V
    //   139: aload 7
    //   141: aload_0
    //   142: getfield 268	com/didisoft/pgp/PGPLib:a	Lcom/didisoft/pgp/bc/BCFactory;
    //   145: aload_3
    //   146: iload 9
    //   148: aaload
    //   149: invokevirtual 451	com/didisoft/pgp/bc/BCFactory:CreatePublicKeyKeyEncryptionMethodGenerator	(Llw/bouncycastle/openpgp/PGPPublicKey;)Llw/bouncycastle/openpgp/operator/PublicKeyKeyEncryptionMethodGenerator;
    //   152: invokevirtual 584	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:addMethod	(Llw/bouncycastle/openpgp/operator/PGPKeyEncryptionMethodGenerator;)V
    //   155: iinc 9 1
    //   158: goto -42 -> 116
    //   161: aload 7
    //   163: aload 4
    //   165: ldc 3
    //   167: newarray byte
    //   169: invokevirtual 587	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:open	(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;
    //   172: astore_3
    //   173: goto +10 -> 183
    //   176: dup
    //   177: astore 9
    //   179: invokestatic 469	com/didisoft/pgp/bc/IOUtil:newPGPException	(Llw/bouncycastle/openpgp/PGPException;)Lcom/didisoft/pgp/PGPException;
    //   182: athrow
    //   183: new 232	lw/bouncycastle/openpgp/PGPCompressedDataGenerator
    //   186: dup
    //   187: iload 8
    //   189: invokespecial 578	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:<init>	(I)V
    //   192: astore 9
    //   194: new 238	lw/bouncycastle/openpgp/PGPLiteralDataGenerator
    //   197: dup
    //   198: invokespecial 594	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:<init>	()V
    //   201: astore 7
    //   203: aconst_null
    //   204: astore 10
    //   206: iload 8
    //   208: ifne +29 -> 237
    //   211: aload 7
    //   213: aload_3
    //   214: bipush 98
    //   216: aload_2
    //   217: aload 5
    //   219: ldc 3
    //   221: newarray byte
    //   223: invokevirtual 598	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:open	(Ljava/io/OutputStream;CLjava/lang/String;Ljava/util/Date;[B)Ljava/io/OutputStream;
    //   226: astore 10
    //   228: aload_1
    //   229: aload 10
    //   231: invokestatic 399	com/didisoft/pgp/PGPLib:pipeAll	(Ljava/io/InputStream;Ljava/io/OutputStream;)V
    //   234: goto +31 -> 265
    //   237: aload 7
    //   239: aload 9
    //   241: aload_3
    //   242: invokevirtual 580	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:open	(Ljava/io/OutputStream;)Ljava/io/OutputStream;
    //   245: bipush 98
    //   247: aload_2
    //   248: aload 5
    //   250: ldc 3
    //   252: newarray byte
    //   254: invokevirtual 598	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:open	(Ljava/io/OutputStream;CLjava/lang/String;Ljava/util/Date;[B)Ljava/io/OutputStream;
    //   257: astore 10
    //   259: aload_1
    //   260: aload 10
    //   262: invokestatic 399	com/didisoft/pgp/PGPLib:pipeAll	(Ljava/io/InputStream;Ljava/io/OutputStream;)V
    //   265: aload 7
    //   267: invokevirtual 596	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:close	()V
    //   270: aload 10
    //   272: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   275: aload_1
    //   276: invokestatic 466	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/InputStream;)V
    //   279: aload 9
    //   281: invokevirtual 579	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:close	()V
    //   284: goto +25 -> 309
    //   287: astore_2
    //   288: aload 7
    //   290: invokevirtual 596	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:close	()V
    //   293: aload 10
    //   295: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   298: aload_1
    //   299: invokestatic 466	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/InputStream;)V
    //   302: aload 9
    //   304: invokevirtual 579	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:close	()V
    //   307: aload_2
    //   308: athrow
    //   309: aload_3
    //   310: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   313: iload 6
    //   315: ifeq +28 -> 343
    //   318: aload 4
    //   320: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   323: goto +25 -> 348
    //   326: astore_1
    //   327: aload_3
    //   328: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   331: iload 6
    //   333: ifeq +8 -> 341
    //   336: aload 4
    //   338: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   341: aload_1
    //   342: athrow
    //   343: return
    //   344: dup
    //   345: astore 4
    //   347: athrow
    //   348: return
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	349	0	this	PGPLib
    //   0	349	1	paramInputStream	InputStream
    //   0	349	2	paramString	String
    //   0	349	3	paramArrayOfPGPPublicKey	PGPPublicKey[]
    //   0	349	4	paramOutputStream	OutputStream
    //   0	349	5	paramDate	Date
    //   0	349	6	paramBoolean1	boolean
    //   0	349	7	paramBoolean2	boolean
    //   0	349	8	paramBoolean3	boolean
    //   42	114	9	n	int
    //   177	126	9	localObject	Object
    //   204	90	10	localOutputStream	OutputStream
    //   176	1	12	localPGPException	lw.bouncycastle.openpgp.PGPException
    //   344	1	13	localIOException	IOException
    // Exception table:
    //   from	to	target	type
    //   113	173	176	lw/bouncycastle/openpgp/PGPException
    //   206	265	287	finally
    //   183	309	326	finally
    //   0	343	344	java/io/IOException
  }
  
  /* Error */
  private void a(InputStream paramInputStream, String paramString1, String paramString2, OutputStream paramOutputStream, boolean paramBoolean1, boolean paramBoolean2)
    throws PGPException
  {
    // Byte code:
    //   0: iload 5
    //   2: ifeq +24 -> 26
    //   5: aload 4
    //   7: astore 4
    //   9: new 229	lw/bouncycastle/bcpg/ArmoredOutputStream
    //   12: dup
    //   13: aload 4
    //   15: invokespecial 572	lw/bouncycastle/bcpg/ArmoredOutputStream:<init>	(Ljava/io/OutputStream;)V
    //   18: astore 4
    //   20: aload_0
    //   21: aload 4
    //   23: invokespecial 318	com/didisoft/pgp/PGPLib:a	(Ljava/io/OutputStream;)V
    //   26: aload_0
    //   27: getfield 271	com/didisoft/pgp/PGPLib:d	Ljava/lang/String;
    //   30: invokestatic 297	com/didisoft/pgp/KeyStore:b	(Ljava/lang/String;)I
    //   33: istore 7
    //   35: aload_0
    //   36: getfield 270	com/didisoft/pgp/PGPLib:c	Ljava/lang/String;
    //   39: invokestatic 299	com/didisoft/pgp/KeyStore:c	(Ljava/lang/String;)I
    //   42: istore 8
    //   44: aload_0
    //   45: getfield 268	com/didisoft/pgp/PGPLib:a	Lcom/didisoft/pgp/bc/BCFactory;
    //   48: iload 8
    //   50: iload 6
    //   52: invokestatic 468	com/didisoft/pgp/bc/IOUtil:getSecureRandom	()Ljava/security/SecureRandom;
    //   55: invokevirtual 446	com/didisoft/pgp/bc/BCFactory:CreatePGPEncryptedDataGenerator	(IZLjava/security/SecureRandom;)Llw/bouncycastle/openpgp/PGPEncryptedDataGenerator;
    //   58: astore 6
    //   60: aload 6
    //   62: aload_0
    //   63: getfield 268	com/didisoft/pgp/PGPLib:a	Lcom/didisoft/pgp/bc/BCFactory;
    //   66: aload_3
    //   67: invokevirtual 443	com/didisoft/pgp/bc/BCFactory:CreatePBEKeyEncryptionMethodGenerator	(Ljava/lang/String;)Llw/bouncycastle/openpgp/operator/PBEKeyEncryptionMethodGenerator;
    //   70: invokevirtual 584	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:addMethod	(Llw/bouncycastle/openpgp/operator/PGPKeyEncryptionMethodGenerator;)V
    //   73: aload_0
    //   74: ldc 56
    //   76: invokespecial 320	com/didisoft/pgp/PGPLib:a	(Ljava/lang/String;)V
    //   79: aload 6
    //   81: aload 4
    //   83: ldc 3
    //   85: newarray byte
    //   87: invokevirtual 587	lw/bouncycastle/openpgp/PGPEncryptedDataGenerator:open	(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;
    //   90: astore_3
    //   91: goto +10 -> 101
    //   94: dup
    //   95: astore 6
    //   97: invokestatic 469	com/didisoft/pgp/bc/IOUtil:newPGPException	(Llw/bouncycastle/openpgp/PGPException;)Lcom/didisoft/pgp/PGPException;
    //   100: athrow
    //   101: new 232	lw/bouncycastle/openpgp/PGPCompressedDataGenerator
    //   104: dup
    //   105: iload 7
    //   107: invokespecial 578	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:<init>	(I)V
    //   110: astore 6
    //   112: new 238	lw/bouncycastle/openpgp/PGPLiteralDataGenerator
    //   115: dup
    //   116: invokespecial 594	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:<init>	()V
    //   119: astore 8
    //   121: iload 7
    //   123: ifne +34 -> 157
    //   126: aload 8
    //   128: aload_3
    //   129: aload_0
    //   130: invokevirtual 395	com/didisoft/pgp/PGPLib:getContentType	()C
    //   133: aload_2
    //   134: new 222	java/util/Date
    //   137: dup
    //   138: invokespecial 563	java/util/Date:<init>	()V
    //   141: ldc 3
    //   143: newarray byte
    //   145: invokevirtual 598	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:open	(Ljava/io/OutputStream;CLjava/lang/String;Ljava/util/Date;[B)Ljava/io/OutputStream;
    //   148: astore_2
    //   149: aload_1
    //   150: aload_2
    //   151: invokestatic 399	com/didisoft/pgp/PGPLib:pipeAll	(Ljava/io/InputStream;Ljava/io/OutputStream;)V
    //   154: goto +36 -> 190
    //   157: aload 8
    //   159: aload 6
    //   161: aload_3
    //   162: invokevirtual 580	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:open	(Ljava/io/OutputStream;)Ljava/io/OutputStream;
    //   165: aload_0
    //   166: invokevirtual 395	com/didisoft/pgp/PGPLib:getContentType	()C
    //   169: aload_2
    //   170: new 222	java/util/Date
    //   173: dup
    //   174: invokespecial 563	java/util/Date:<init>	()V
    //   177: ldc 3
    //   179: newarray byte
    //   181: invokevirtual 598	lw/bouncycastle/openpgp/PGPLiteralDataGenerator:open	(Ljava/io/OutputStream;CLjava/lang/String;Ljava/util/Date;[B)Ljava/io/OutputStream;
    //   184: astore_2
    //   185: aload_1
    //   186: aload_2
    //   187: invokestatic 399	com/didisoft/pgp/PGPLib:pipeAll	(Ljava/io/InputStream;Ljava/io/OutputStream;)V
    //   190: aload_2
    //   191: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   194: aload 6
    //   196: invokevirtual 579	lw/bouncycastle/openpgp/PGPCompressedDataGenerator:close	()V
    //   199: aload_1
    //   200: invokestatic 466	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/InputStream;)V
    //   203: aload_3
    //   204: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   207: aload 4
    //   209: invokevirtual 513	java/io/OutputStream:flush	()V
    //   212: iload 5
    //   214: ifeq +37 -> 251
    //   217: aload 4
    //   219: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   222: goto +47 -> 269
    //   225: astore_2
    //   226: aload_1
    //   227: invokestatic 466	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/InputStream;)V
    //   230: aload_3
    //   231: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   234: aload 4
    //   236: invokevirtual 513	java/io/OutputStream:flush	()V
    //   239: iload 5
    //   241: ifeq +8 -> 249
    //   244: aload 4
    //   246: invokestatic 467	com/didisoft/pgp/bc/IOUtil:closeStream	(Ljava/io/OutputStream;)V
    //   249: aload_2
    //   250: athrow
    //   251: return
    //   252: astore 4
    //   254: new 167	com/didisoft/pgp/PGPException
    //   257: dup
    //   258: aload 4
    //   260: invokevirtual 506	java/io/IOException:getMessage	()Ljava/lang/String;
    //   263: aload 4
    //   265: invokespecial 306	com/didisoft/pgp/PGPException:<init>	(Ljava/lang/String;Ljava/lang/Exception;)V
    //   268: athrow
    //   269: return
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	270	0	this	PGPLib
    //   0	270	1	paramInputStream	InputStream
    //   0	270	2	paramString1	String
    //   0	270	3	paramString2	String
    //   0	270	4	paramOutputStream	OutputStream
    //   0	270	5	paramBoolean1	boolean
    //   0	270	6	paramBoolean2	boolean
    //   33	89	7	n	int
    //   42	7	8	i1	int
    //   119	39	8	localPGPLiteralDataGenerator	PGPLiteralDataGenerator
    //   94	1	10	localPGPException	lw.bouncycastle.openpgp.PGPException
    // Exception table:
    //   from	to	target	type
    //   60	91	94	lw/bouncycastle/openpgp/PGPException
    //   101	199	225	finally
    //   0	251	252	java/io/IOException
  }
  
  private String a(PGPLiteralData paramPGPLiteralData, PGPSignature paramPGPSignature, OutputStream paramOutputStream)
    throws IOException
  {
    String str = paramPGPLiteralData.getFileName();
    a("Found literal data packet");
    a("Decrypted file original name is {0}", str);
    InputStream localInputStream = null;
    try
    {
      localInputStream = paramPGPLiteralData.getInputStream();
      paramPGPLiteralData = new byte[1048576];
      int n;
      while ((n = localInputStream.read(paramPGPLiteralData, 0, paramPGPLiteralData.length)) >= 0)
      {
        if (paramPGPSignature != null) {
          paramPGPSignature.update(paramPGPLiteralData, 0, n);
        }
        if (paramOutputStream != null) {
          paramOutputStream.write(paramPGPLiteralData, 0, n);
        }
      }
      IOUtil.closeStream(localInputStream);
    }
    finally
    {
      IOUtil.closeStream(localInputStream);
    }
    return str;
  }
  
  private String[] a(PGPLiteralData paramPGPLiteralData, PGPSignature paramPGPSignature, String paramString1, String paramString2)
    throws IOException
  {
    a("Found literal data packet");
    String str;
    if (((str = paramPGPLiteralData.getFileName()).toUpperCase().endsWith(".TAR")) && (l))
    {
      a("Found multiple file archive");
      return (localObject = new TarInputStream(paramPGPLiteralData.getInputStream())).extractAll(paramString1);
    }
    Object localObject = null;
    try
    {
      if ((str == null) || ("".equals(str))) {
        if ((paramString2 != null) && (!"".equals(paramString2)))
        {
          if ((str = new File(paramString2).getName()).lastIndexOf(".") > 0) {
            str = str.substring(0, str.lastIndexOf("."));
          }
        }
        else {
          str = "output";
        }
      }
      localObject = new FileOutputStream(paramString1 + File.separator + str);
      a("Extracting to {0}", paramString1 + File.separator + str);
      paramPGPLiteralData = paramPGPLiteralData.getInputStream();
      paramString1 = new byte[1048576];
      while ((paramString2 = paramPGPLiteralData.read(paramString1, 0, paramString1.length)) >= 0)
      {
        if (paramPGPSignature != null) {
          paramPGPSignature.update(paramString1, 0, paramString2);
        }
        ((FileOutputStream)localObject).write(paramString1, 0, paramString2);
      }
      IOUtil.closeStream(paramPGPLiteralData);
      IOUtil.closeStream((OutputStream)localObject);
    }
    finally
    {
      IOUtil.closeStream((OutputStream)localObject);
    }
    tmp271_268[0] = str;
    return tmp271_268;
  }
  
  private String a(PGPLiteralData paramPGPLiteralData, PGPOnePassSignature paramPGPOnePassSignature, OutputStream paramOutputStream)
    throws IOException
  {
    String str = paramPGPLiteralData.getFileName();
    paramPGPLiteralData = paramPGPLiteralData.getInputStream();
    a("Found literal data packet");
    a("Decrypted file original name is {0}", str);
    byte[] arrayOfByte = new byte[1048576];
    try
    {
      int n;
      while ((n = paramPGPLiteralData.read(arrayOfByte, 0, arrayOfByte.length)) >= 0)
      {
        if (paramPGPOnePassSignature != null) {
          paramPGPOnePassSignature.update(arrayOfByte, 0, n);
        }
        if (paramOutputStream != null) {
          paramOutputStream.write(arrayOfByte, 0, n);
        }
      }
      IOUtil.closeStream(paramPGPLiteralData);
    }
    finally
    {
      IOUtil.closeStream(paramPGPLiteralData);
    }
    return str;
  }
  
  private String[] a(PGPLiteralData paramPGPLiteralData, PGPOnePassSignature paramPGPOnePassSignature, String paramString1, String paramString2)
    throws IOException
  {
    a("Found literal data packet");
    String str;
    if (((str = paramPGPLiteralData.getFileName()).toUpperCase().endsWith(".TAR")) && (l))
    {
      a("Found multiple file archive");
      return (localObject = new TarInputStream(paramPGPLiteralData.getInputStream())).extractAll(paramString1);
    }
    Object localObject = paramPGPLiteralData.getInputStream();
    a("Decrypted file original name is {0}", paramPGPLiteralData.getFileName());
    if ((str == null) || ("".equals(str))) {
      if ((paramString2 != null) && (!"".equals(paramString2)))
      {
        if ((str = new File(paramString2).getName()).lastIndexOf(".") > 0) {
          str = str.substring(0, str.lastIndexOf("."));
        }
      }
      else {
        str = "output";
      }
    }
    a("Extracting to {0}", paramString1 + File.separator + str);
    paramPGPLiteralData = new FileOutputStream(paramString1 + File.separator + str);
    paramString1 = new byte[1048576];
    try
    {
      while ((paramString2 = ((InputStream)localObject).read(paramString1, 0, paramString1.length)) >= 0)
      {
        if (paramPGPOnePassSignature != null) {
          paramPGPOnePassSignature.update(paramString1, 0, paramString2);
        }
        paramPGPLiteralData.write(paramString1, 0, paramString2);
      }
      IOUtil.closeStream((InputStream)localObject);
      IOUtil.closeStream(paramPGPLiteralData);
    }
    finally
    {
      IOUtil.closeStream(paramPGPLiteralData);
    }
    tmp277_274[0] = str;
    return tmp277_274;
  }
  
  private String a(PGPCompressedData paramPGPCompressedData, boolean paramBoolean, PGPLib.a paramA, KeyStore paramKeyStore, InputStream paramInputStream, OutputStream paramOutputStream)
    throws PGPException, IOException
  {
    a("Decrypted data compression algorithm is {0}", KeyStore.a(paramPGPCompressedData.getAlgorithm()));
    Object localObject1;
    try
    {
      paramPGPCompressedData.getDataStream();
      paramPGPCompressedData = new BufferedInputStream(paramPGPCompressedData.getDataStream());
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(localObject1 = localPGPException);
    }
    try
    {
      Object localObject2;
      if (((localObject2 = (localObject1 = new PGPObjectFactory2(paramPGPCompressedData)).nextObject()) instanceof PGPLiteralData))
      {
        paramBoolean = a((PGPLiteralData)localObject2, null, paramOutputStream);
        return paramBoolean;
      }
      if ((localObject2 instanceof PGPOnePassSignatureList))
      {
        if (paramBoolean)
        {
          paramBoolean = a((PGPOnePassSignatureList)localObject2, (PGPObjectFactory)localObject1, paramKeyStore, paramInputStream, paramOutputStream, paramA);
          return paramBoolean;
        }
        paramBoolean = a((PGPOnePassSignatureList)localObject2, (PGPObjectFactory)localObject1, null, null, paramOutputStream, paramA);
        return paramBoolean;
      }
      if ((localObject2 instanceof PGPSignatureList))
      {
        if (paramBoolean)
        {
          paramBoolean = a((PGPSignatureList)localObject2, (PGPObjectFactory)localObject1, paramKeyStore, paramInputStream, paramOutputStream, paramA);
          return paramBoolean;
        }
        paramBoolean = a((PGPSignatureList)localObject2, (PGPObjectFactory)localObject1, null, null, paramOutputStream, paramA);
        return paramBoolean;
      }
      throw new PGPException("Unknown message format: " + localObject2.getClass().getName());
    }
    finally
    {
      IOUtil.closeStream(paramPGPCompressedData);
    }
  }
  
  private String[] a(PGPCompressedData paramPGPCompressedData, boolean paramBoolean, PGPLib.a paramA, KeyStore paramKeyStore, InputStream paramInputStream, String paramString1, String paramString2)
    throws PGPException, IOException
  {
    a("Decrypted data compression algorithm is {0}", KeyStore.a(paramPGPCompressedData.getAlgorithm()));
    Object localObject1;
    try
    {
      paramPGPCompressedData = new BufferedInputStream(paramPGPCompressedData.getDataStream());
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(localObject1 = localPGPException);
    }
    try
    {
      Object localObject2;
      if (((localObject2 = (localObject1 = new PGPObjectFactory2(paramPGPCompressedData)).nextObject()) instanceof PGPLiteralData))
      {
        paramBoolean = a((PGPLiteralData)localObject2, null, paramString1, paramString2);
        return paramBoolean;
      }
      if ((localObject2 instanceof PGPOnePassSignatureList))
      {
        if (paramBoolean)
        {
          paramBoolean = a((PGPOnePassSignatureList)localObject2, (PGPObjectFactory)localObject1, paramKeyStore, paramInputStream, paramString1, paramString2, paramA);
          return paramBoolean;
        }
        paramBoolean = a((PGPOnePassSignatureList)localObject2, (PGPObjectFactory)localObject1, null, null, paramString1, paramString2, paramA);
        return paramBoolean;
      }
      if ((localObject2 instanceof PGPSignatureList))
      {
        if (paramBoolean)
        {
          paramBoolean = a((PGPSignatureList)localObject2, (PGPObjectFactory)localObject1, paramKeyStore, paramInputStream, paramString1, paramString2, paramA);
          return paramBoolean;
        }
        paramBoolean = a((PGPSignatureList)localObject2, (PGPObjectFactory)localObject1, null, null, paramString1, paramString2, paramA);
        return paramBoolean;
      }
      throw new PGPException("Unknown message format: " + localObject2.getClass().getName());
    }
    finally
    {
      IOUtil.closeStream(paramPGPCompressedData);
    }
  }
  
  private String a(PGPOnePassSignatureList paramPGPOnePassSignatureList, PGPObjectFactory paramPGPObjectFactory, KeyStore paramKeyStore, InputStream paramInputStream, OutputStream paramOutputStream, PGPLib.a paramA)
    throws PGPException, IOException
  {
    a("Found signature");
    PGPOnePassSignature localPGPOnePassSignature = null;
    PGPPublicKey localPGPPublicKey = null;
    if ((paramInputStream != null) || (paramKeyStore != null))
    {
      for (int n = 0; n != paramPGPOnePassSignatureList.size(); n++)
      {
        localPGPOnePassSignature = paramPGPOnePassSignatureList.get(n);
        if (paramInputStream != null) {
          localPGPPublicKey = readPublicVerificationKey(paramInputStream, localPGPOnePassSignature.getKeyID());
        } else {
          localPGPPublicKey = readPublicVerificationKey(paramKeyStore, localPGPOnePassSignature.getKeyID());
        }
        if (localPGPPublicKey != null)
        {
          a("Message signed with Key Id {0}", KeyPairInformation.keyId2Hex(localPGPPublicKey.getKeyID()));
          break;
        }
        a("Message signed with Unknown Key Id {0}", KeyPairInformation.keyId2Hex(localPGPOnePassSignature.getKeyID()));
      }
      if (localPGPPublicKey != null) {
        a.initVerify(localPGPOnePassSignature, localPGPPublicKey);
      }
    }
    Object localObject;
    if (((localObject = paramPGPObjectFactory.nextObject()) instanceof PGPLiteralData)) {
      paramPGPOnePassSignatureList = a((PGPLiteralData)localObject, localPGPPublicKey != null ? localPGPOnePassSignature : null, paramOutputStream);
    } else {
      throw new PGPException("Unknown message format: " + localObject.getClass().getName());
    }
    if ((paramInputStream != null) || (paramKeyStore != null)) {
      if (localPGPPublicKey == null)
      {
        a("The signature of the message does not correspond to the provided public key.");
        a = SignatureCheckResult.PublicKeyNotMatching;
      }
      else if (((paramPGPObjectFactory = paramPGPObjectFactory.nextObject()) != null) && (localPGPOnePassSignature != null))
      {
        paramPGPObjectFactory = (PGPSignatureList)paramPGPObjectFactory;
        try
        {
          if (!localPGPOnePassSignature.verify(paramPGPObjectFactory.get(0)))
          {
            a("The signature of the message did not passed verification.");
            a = SignatureCheckResult.SignatureBroken;
          }
          else
          {
            a = SignatureCheckResult.SignatureVerified;
          }
        }
        catch (lw.bouncycastle.openpgp.PGPException localPGPException)
        {
          throw IOUtil.newPGPException(paramPGPOnePassSignatureList = localPGPException);
        }
      }
    }
    return paramPGPOnePassSignatureList;
  }
  
  private String[] a(PGPOnePassSignatureList paramPGPOnePassSignatureList, PGPObjectFactory paramPGPObjectFactory, KeyStore paramKeyStore, InputStream paramInputStream, String paramString1, String paramString2, PGPLib.a paramA)
    throws PGPException, IOException
  {
    a("Found signature");
    PGPOnePassSignature localPGPOnePassSignature = null;
    PGPPublicKey localPGPPublicKey = null;
    if ((paramInputStream != null) || (paramKeyStore != null))
    {
      for (int n = 0; n != paramPGPOnePassSignatureList.size(); n++)
      {
        localPGPOnePassSignature = paramPGPOnePassSignatureList.get(n);
        if (paramInputStream != null) {
          localPGPPublicKey = readPublicVerificationKey(paramInputStream, localPGPOnePassSignature.getKeyID());
        } else {
          localPGPPublicKey = readPublicVerificationKey(paramKeyStore, localPGPOnePassSignature.getKeyID());
        }
        if (localPGPPublicKey != null)
        {
          a("The message is signed with Key Id {0}", KeyPairInformation.keyId2Hex(localPGPPublicKey.getKeyID()));
          break;
        }
        a("The message is signed with Unknown Key Id {0}", KeyPairInformation.keyId2Hex(localPGPOnePassSignature.getKeyID()));
      }
      if (localPGPPublicKey != null) {
        a.initVerify(localPGPOnePassSignature, localPGPPublicKey);
      }
    }
    Object localObject;
    if (((localObject = paramPGPObjectFactory.nextObject()) instanceof PGPLiteralData)) {
      paramPGPOnePassSignatureList = a((PGPLiteralData)localObject, localPGPPublicKey != null ? localPGPOnePassSignature : null, paramString1, paramString2);
    } else {
      throw new PGPException("Unknown message format: " + localObject.getClass().getName());
    }
    if ((paramInputStream != null) || (paramKeyStore != null)) {
      if (localPGPPublicKey == null)
      {
        a("The signature of the message does not correspond to the provided public key.");
        a = SignatureCheckResult.PublicKeyNotMatching;
      }
      else if (((paramPGPObjectFactory = paramPGPObjectFactory.nextObject()) != null) && (localPGPOnePassSignature != null))
      {
        paramPGPObjectFactory = (PGPSignatureList)paramPGPObjectFactory;
        try
        {
          if (!localPGPOnePassSignature.verify(paramPGPObjectFactory.get(0)))
          {
            a("The signature of the message did not passed verification.");
            a = SignatureCheckResult.SignatureBroken;
          }
          else
          {
            a("The signature of the message passed verification.");
            a = SignatureCheckResult.SignatureVerified;
          }
        }
        catch (lw.bouncycastle.openpgp.PGPException localPGPException)
        {
          throw IOUtil.newPGPException(paramPGPOnePassSignatureList = localPGPException);
        }
      }
    }
    return paramPGPOnePassSignatureList;
  }
  
  private String a(PGPSignatureList paramPGPSignatureList, PGPObjectFactory paramPGPObjectFactory, KeyStore paramKeyStore, InputStream paramInputStream, OutputStream paramOutputStream, PGPLib.a paramA)
    throws PGPException, IOException
  {
    a("Found signature version 3");
    PGPSignature localPGPSignature = null;
    PGPPublicKey localPGPPublicKey = null;
    if ((paramInputStream != null) || (paramKeyStore != null))
    {
      for (int n = 0; n < paramPGPSignatureList.size(); n++) {
        if (((localPGPSignature = paramPGPSignatureList.get(n)).getSignatureType() == 0) || (localPGPSignature.getSignatureType() == 1) || (localPGPSignature.getSignatureType() == 16))
        {
          if (paramInputStream != null) {
            localPGPPublicKey = readPublicVerificationKey(paramInputStream, localPGPSignature.getKeyID());
          } else {
            localPGPPublicKey = readPublicVerificationKey(paramKeyStore, localPGPSignature.getKeyID());
          }
          if (localPGPPublicKey != null)
          {
            a("The message is signed with Key Id {0}", KeyPairInformation.keyId2Hex(localPGPPublicKey.getKeyID()));
            break;
          }
          a("The message is signed with Unknown Key Id {0}", KeyPairInformation.keyId2Hex(localPGPSignature.getKeyID()));
        }
      }
      if (localPGPPublicKey != null) {
        a.initVerify(localPGPSignature, localPGPPublicKey);
      }
    }
    Object localObject;
    if (((localObject = paramPGPObjectFactory.nextObject()) instanceof PGPLiteralData))
    {
      paramPGPSignatureList = a((PGPLiteralData)localObject, localPGPPublicKey != null ? localPGPSignature : null, paramOutputStream);
    }
    else
    {
      if (localObject == null) {
        throw new DetachedSignatureException("This is a detached signature file");
      }
      throw new PGPException("Unknown message format: " + localObject.getClass().getName());
    }
    if ((paramInputStream != null) || (paramKeyStore != null)) {
      if (localPGPPublicKey == null)
      {
        a("The signature of the message does not correspond to the provided public key.");
        a = SignatureCheckResult.PublicKeyNotMatching;
      }
      else
      {
        try
        {
          if (!localPGPSignature.verify())
          {
            a("The signature of the message did not passed verification.");
            a = SignatureCheckResult.SignatureBroken;
          }
          else
          {
            a = SignatureCheckResult.SignatureVerified;
          }
        }
        catch (lw.bouncycastle.openpgp.PGPException localPGPException)
        {
          throw IOUtil.newPGPException(paramPGPSignatureList = localPGPException);
        }
      }
    }
    return paramPGPSignatureList;
  }
  
  private String[] a(PGPSignatureList paramPGPSignatureList, PGPObjectFactory paramPGPObjectFactory, KeyStore paramKeyStore, InputStream paramInputStream, String paramString1, String paramString2, PGPLib.a paramA)
    throws PGPException, IOException
  {
    PGPSignature localPGPSignature = null;
    PGPPublicKey localPGPPublicKey = null;
    if ((paramInputStream != null) || (paramKeyStore != null))
    {
      for (int n = 0; n < paramPGPSignatureList.size(); n++) {
        if (((localPGPSignature = paramPGPSignatureList.get(n)).getSignatureType() == 0) || (localPGPSignature.getSignatureType() == 1) || (localPGPSignature.getSignatureType() == 16))
        {
          if (paramInputStream != null) {
            localPGPPublicKey = readPublicVerificationKey(paramInputStream, localPGPSignature.getKeyID());
          } else {
            localPGPPublicKey = readPublicVerificationKey(paramKeyStore, localPGPSignature.getKeyID());
          }
          if (localPGPPublicKey != null)
          {
            a("Message signed with Key Id {0}", KeyPairInformation.keyId2Hex(localPGPPublicKey.getKeyID()));
            break;
          }
          a("Message signed with Unknown Key Id {0}", KeyPairInformation.keyId2Hex(localPGPSignature.getKeyID()));
        }
      }
      if (localPGPPublicKey != null) {
        a.initVerify(localPGPSignature, localPGPPublicKey);
      }
    }
    Object localObject;
    if (((localObject = paramPGPObjectFactory.nextObject()) instanceof PGPLiteralData))
    {
      paramPGPSignatureList = a((PGPLiteralData)localObject, localPGPPublicKey != null ? localPGPSignature : null, paramString1, paramString2);
    }
    else
    {
      if (localObject == null) {
        throw new DetachedSignatureException("This is a detached signature file");
      }
      throw new PGPException("Unknown message format: " + localObject.getClass().getName());
    }
    if ((paramInputStream != null) || (paramKeyStore != null))
    {
      if (localPGPPublicKey == null)
      {
        a("The signature of the message does not correspond to the provided public key.");
        a = SignatureCheckResult.PublicKeyNotMatching;
      }
      try
      {
        if (!localPGPSignature.verify())
        {
          a("The signature of the message did not passed verification.");
          a = SignatureCheckResult.SignatureBroken;
        }
        else
        {
          a("The signature of the message passed verification.");
          a = SignatureCheckResult.SignatureVerified;
        }
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException)
      {
        throw IOUtil.newPGPException(paramPGPSignatureList = localPGPException);
      }
    }
    return paramPGPSignatureList;
  }
  
  private String a(PGPEncryptedDataList paramPGPEncryptedDataList, boolean paramBoolean, PGPLib.a paramA, String paramString, KeyStore paramKeyStore, InputStream paramInputStream, OutputStream paramOutputStream)
    throws IOException, WrongPasswordException, PGPException
  {
    paramBoolean = null;
    paramKeyStore = null;
    paramInputStream = null;
    Object localObject;
    if ((paramPGPEncryptedDataList instanceof PGP2xPBEEncryptedData))
    {
      try
      {
        a("Password encrypted data packet found");
        paramKeyStore = ((PGP2xPBEEncryptedData)paramPGPEncryptedDataList).getDataStream(paramString.toCharArray());
      }
      catch (PGPDataValidationException paramPGPEncryptedDataList)
      {
        throw new WrongPasswordException("The supplied password is incorrect.", paramPGPEncryptedDataList.getUnderlyingException());
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException1)
      {
        throw IOUtil.newPGPException(paramPGPEncryptedDataList = localPGPException1);
      }
    }
    else
    {
      paramPGPEncryptedDataList = paramPGPEncryptedDataList.getEncryptedDataObjects();
      while (paramPGPEncryptedDataList.hasNext()) {
        if (((localObject = paramPGPEncryptedDataList.next()) instanceof PGPPBEEncryptedData))
        {
          a("Password encrypted data packet found");
          paramInputStream = (PGPPBEEncryptedData)localObject;
          try
          {
            paramKeyStore = paramInputStream.getDataStream(a.CreatePBEDataDecryptorFactory(paramString));
          }
          catch (PGPDataValidationException paramBoolean)
          {
            paramBoolean = new WrongPasswordException("The supplied password is incorrect.", paramBoolean.getUnderlyingException());
          }
          catch (lw.bouncycastle.openpgp.PGPException localPGPException2)
          {
            throw IOUtil.newPGPException(paramBoolean = localPGPException2);
          }
        }
      }
    }
    if ((paramKeyStore == null) && (paramBoolean != null)) {
      throw paramBoolean;
    }
    if (paramKeyStore == null) {
      throw new FileIsEncryptedException("The file is encrypted with an OpenPGP key.");
    }
    if (((paramBoolean = (localObject = new PGPObjectFactory2(paramKeyStore)).nextObject()) instanceof PGPCompressedData)) {
      paramPGPEncryptedDataList = a((PGPCompressedData)paramBoolean, false, paramA, null, null, paramOutputStream);
    } else if ((paramBoolean instanceof PGPOnePassSignatureList)) {
      paramPGPEncryptedDataList = a((PGPOnePassSignatureList)paramBoolean, (PGPObjectFactory)localObject, null, null, paramOutputStream, paramA);
    } else if ((paramBoolean instanceof PGPSignatureList)) {
      paramPGPEncryptedDataList = a((PGPSignatureList)paramBoolean, (PGPObjectFactory)localObject, null, null, paramOutputStream, paramA);
    } else if ((paramBoolean instanceof PGPLiteralData)) {
      paramPGPEncryptedDataList = a((PGPLiteralData)paramBoolean, null, paramOutputStream);
    } else {
      throw new PGPException("Unknown message format: " + paramBoolean.getClass().getName());
    }
    if ((paramInputStream != null) && (paramInputStream.isIntegrityProtected())) {
      try
      {
        if (!paramInputStream.verify())
        {
          a("Integrity check failed!");
          throw new IntegrityCheckException("The encrypted data is corrupted!");
        }
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException3) {}
    }
    return paramPGPEncryptedDataList;
  }
  
  private String a(PGPEncryptedDataList paramPGPEncryptedDataList, boolean paramBoolean, PGPLib.a paramA, KeyStore paramKeyStore, InputStream paramInputStream1, String paramString, InputStream paramInputStream2, OutputStream paramOutputStream)
    throws IOException, PGPException, WrongPrivateKeyException, WrongPasswordException, FileIsPBEEncryptedException, IntegrityCheckException, DetachedSignatureException
  {
    PGPSecretKeyRingCollection localPGPSecretKeyRingCollection;
    if (paramInputStream1 != null) {
      localPGPSecretKeyRingCollection = createPGPSecretKeyRingCollection(paramInputStream1);
    } else {
      localPGPSecretKeyRingCollection = b;
    }
    Object localObject1 = null;
    PGPPrivateKey localPGPPrivateKey = null;
    PGPPublicKeyEncryptedData localPGPPublicKeyEncryptedData = null;
    String[] arrayOfString;
    a(arrayOfString = new String[paramPGPEncryptedDataList.size()], "Password encrypted");
    Object localObject4;
    Object localObject2;
    for (int n = 0; n < paramPGPEncryptedDataList.size(); n++) {
      if (((localObject4 = paramPGPEncryptedDataList.get(n)) instanceof PGPPublicKeyEncryptedData))
      {
        localPGPPublicKeyEncryptedData = (PGPPublicKeyEncryptedData)localObject4;
        arrayOfString[n] = KeyPairInformation.keyId2Hex(localPGPPublicKeyEncryptedData.getKeyID());
        a("Public key encrypted data packet found");
        a("Encrypted with key {0}", "0".equals(arrayOfString[n]) ? "wildcard" : arrayOfString[n]);
        try
        {
          if (((localPGPPrivateKey = getPrivateKey(localPGPSecretKeyRingCollection, localPGPPublicKeyEncryptedData.getKeyID(), paramString)) != null) && (paramKeyStore != null))
          {
            paramKeyStore.a(localPGPPublicKeyEncryptedData.getKeyID());
            localPGPPrivateKey = getPrivateKey(localPGPSecretKeyRingCollection, localPGPPublicKeyEncryptedData.getKeyID(), paramString);
          }
        }
        catch (WrongPasswordException localWrongPasswordException)
        {
          localPGPPrivateKey = null;
          localObject2 = localWrongPasswordException;
        }
        if (localPGPPrivateKey != null) {
          break;
        }
      }
    }
    if ((localPGPPrivateKey == null) && (localObject2 != null)) {
      throw ((Throwable)localObject2);
    }
    if (localPGPPublicKeyEncryptedData == null)
    {
      a("This file is encrypted with a password.");
      throw new FileIsPBEEncryptedException("This file is encrypted with a password.");
    }
    Object localObject3;
    if (localPGPPrivateKey == null)
    {
      if (paramInputStream1 != null)
      {
        if ((localPGPSecretKeyRingCollection != null) && (localPGPSecretKeyRingCollection.size() == 0)) {
          throw new WrongPrivateKeyException("Decryption of data encrypted using KEY-ID(s) : " + b(arrayOfString, ",") + " failed, The provided key is not a valid OpenPGP private key.");
        }
        localObject3 = "";
        if ((localObject4 = localPGPSecretKeyRingCollection.getKeyRings()).hasNext()) {
          localObject3 = KeyPairInformation.keyId2Hex((localObject2 = (PGPSecretKeyRing)((Iterator)localObject4).next()).getSecretKey().getKeyID());
        }
        throw new WrongPrivateKeyException("Decryption of data encrypted using KEY-ID(s) : " + b(arrayOfString, ",") + " failed, using incorrect private KEY-ID :" + (String)localObject3);
      }
      throw new WrongPrivateKeyException("Decryption of data encrypted using KEY-ID(s) : " + b(arrayOfString, ",") + " failed, no matching key was found in the KeyStore.");
    }
    try
    {
      localObject3 = localPGPPublicKeyEncryptedData.getDataStream(a.CreatePublicKeyDataDecryptorFactory(localPGPPrivateKey));
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException1)
    {
      throw IOUtil.newPGPException(localObject4 = localPGPException1);
    }
    if (((paramPGPEncryptedDataList = (localObject2 = new PGPObjectFactory2((InputStream)localObject3)).nextObject()) instanceof PGPCompressedData))
    {
      localObject4 = a((PGPCompressedData)paramPGPEncryptedDataList, paramBoolean, paramA, paramKeyStore, paramInputStream2, paramOutputStream);
    }
    else if ((paramPGPEncryptedDataList instanceof PGPOnePassSignatureList))
    {
      a("Signature found!");
      if (paramBoolean) {
        localObject4 = a((PGPOnePassSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, paramKeyStore, paramInputStream2, paramOutputStream, paramA);
      } else {
        localObject4 = a((PGPOnePassSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, null, null, paramOutputStream, paramA);
      }
    }
    else if ((paramPGPEncryptedDataList instanceof PGPSignatureList))
    {
      a("Signature found (version 3, old style)");
      if (paramBoolean) {
        localObject4 = a((PGPSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, paramKeyStore, paramInputStream2, paramOutputStream, paramA);
      } else {
        localObject4 = a((PGPSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, null, null, paramOutputStream, paramA);
      }
    }
    else if ((paramPGPEncryptedDataList instanceof PGPLiteralData))
    {
      localObject4 = a((PGPLiteralData)paramPGPEncryptedDataList, null, paramOutputStream);
    }
    else
    {
      throw new NonPGPDataException("Unknown message format: " + paramPGPEncryptedDataList.getClass().getName());
    }
    if (localPGPPublicKeyEncryptedData.isIntegrityProtected()) {
      try
      {
        if (!localPGPPublicKeyEncryptedData.verify())
        {
          a("Integrity check failed!");
          throw new IntegrityCheckException("The encrypted data is corrupted!");
        }
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException2) {}
    }
    return localObject4;
  }
  
  private String[] a(PGPEncryptedDataList paramPGPEncryptedDataList, boolean paramBoolean, PGPLib.a paramA, KeyStore paramKeyStore, InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, String paramString3)
    throws IOException, WrongPasswordException, WrongPrivateKeyException, PGPException
  {
    PGPPrivateKey localPGPPrivateKey = null;
    PGPSecretKeyRingCollection localPGPSecretKeyRingCollection;
    if (paramInputStream1 != null) {
      localPGPSecretKeyRingCollection = createPGPSecretKeyRingCollection(paramInputStream1);
    } else {
      localPGPSecretKeyRingCollection = b;
    }
    Object localObject1 = null;
    PGPPublicKeyEncryptedData localPGPPublicKeyEncryptedData = null;
    String[] arrayOfString;
    a(arrayOfString = new String[paramPGPEncryptedDataList.size()], "Password encrypted");
    Object localObject4;
    Object localObject2;
    for (int n = 0; n < paramPGPEncryptedDataList.size(); n++) {
      if (((localObject4 = paramPGPEncryptedDataList.get(n)) instanceof PGPPublicKeyEncryptedData))
      {
        localPGPPublicKeyEncryptedData = (PGPPublicKeyEncryptedData)localObject4;
        arrayOfString[n] = KeyPairInformation.keyId2Hex(localPGPPublicKeyEncryptedData.getKeyID());
        a("Encrypted with key ID {0}", "0".equals(arrayOfString[n]) ? "wildcard" : arrayOfString[n]);
        try
        {
          if (((localPGPPrivateKey = getPrivateKey(localPGPSecretKeyRingCollection, localPGPPublicKeyEncryptedData.getKeyID(), paramString1)) != null) && (paramKeyStore != null))
          {
            paramKeyStore.a(localPGPPublicKeyEncryptedData.getKeyID());
            localPGPPrivateKey = getPrivateKey(localPGPSecretKeyRingCollection, localPGPPublicKeyEncryptedData.getKeyID(), paramString1);
          }
        }
        catch (WrongPasswordException localWrongPasswordException)
        {
          localPGPPrivateKey = null;
          localObject2 = localWrongPasswordException;
        }
        if (localPGPPrivateKey != null) {
          break;
        }
      }
    }
    if ((localPGPPrivateKey == null) && (localObject2 != null)) {
      throw ((Throwable)localObject2);
    }
    if (localPGPPublicKeyEncryptedData == null)
    {
      a("This file is encrypted with a password.");
      throw new FileIsPBEEncryptedException("This file is encrypted with a password.");
    }
    Object localObject3;
    if (localPGPPrivateKey == null)
    {
      if (paramInputStream1 != null)
      {
        if ((localPGPSecretKeyRingCollection != null) && (localPGPSecretKeyRingCollection.size() == 0)) {
          throw new WrongPrivateKeyException("Decryption of data encrypted using KEY-ID(s) : " + b(arrayOfString, ",") + " failed, The provided key is not a valid OpenPGP private key.");
        }
        localObject3 = "";
        if ((localObject4 = localPGPSecretKeyRingCollection.getKeyRings()).hasNext()) {
          localObject3 = KeyPairInformation.keyId2Hex((localObject2 = (PGPSecretKeyRing)((Iterator)localObject4).next()).getSecretKey().getKeyID());
        }
        throw new WrongPrivateKeyException("Decryption of data encrypted using KEY-ID(s) : " + b(arrayOfString, ",") + " failed, using incorrect private KEY-ID :" + (String)localObject3);
      }
      throw new WrongPrivateKeyException("Decryption of data encrypted using KEY-ID(s) : " + b(arrayOfString, ",") + " failed, no matching key was found in the KeyStore.");
    }
    try
    {
      localObject3 = localPGPPublicKeyEncryptedData.getDataStream(a.CreatePublicKeyDataDecryptorFactory(localPGPPrivateKey));
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException1)
    {
      throw IOUtil.newPGPException(localObject4 = localPGPException1);
    }
    if (((paramPGPEncryptedDataList = (localObject2 = new PGPObjectFactory2((InputStream)localObject3)).nextObject()) instanceof PGPCompressedData)) {
      localObject4 = a((PGPCompressedData)paramPGPEncryptedDataList, paramBoolean, paramA, paramKeyStore, paramInputStream2, paramString2, paramString3);
    } else if ((paramPGPEncryptedDataList instanceof PGPOnePassSignatureList))
    {
      if (paramBoolean) {
        localObject4 = a((PGPOnePassSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, paramKeyStore, paramInputStream2, paramString2, paramString3, paramA);
      } else {
        localObject4 = a((PGPOnePassSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, null, null, paramString2, paramString3, paramA);
      }
    }
    else if ((paramPGPEncryptedDataList instanceof PGPSignatureList))
    {
      if (paramBoolean) {
        localObject4 = a((PGPSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, paramKeyStore, paramInputStream2, paramString2, paramString3, paramA);
      } else {
        localObject4 = a((PGPSignatureList)paramPGPEncryptedDataList, (PGPObjectFactory)localObject2, null, null, paramString2, paramString3, paramA);
      }
    }
    else if ((paramPGPEncryptedDataList instanceof PGPLiteralData)) {
      localObject4 = a((PGPLiteralData)paramPGPEncryptedDataList, null, paramString2, paramString3);
    } else {
      throw new PGPException("Unknown message format: " + paramPGPEncryptedDataList.getClass().getName());
    }
    if (localPGPPublicKeyEncryptedData.isIntegrityProtected()) {
      try
      {
        if (!localPGPPublicKeyEncryptedData.verify())
        {
          a("Integrity check failed!");
          throw new IntegrityCheckException("The encrypted data is corrupted!");
        }
      }
      catch (lw.bouncycastle.openpgp.PGPException localPGPException2) {}
    }
    return localObject4;
  }
  
  private static String a(PGPPublicKey paramPGPPublicKey)
  {
    if ((paramPGPPublicKey = paramPGPPublicKey.getUserIDs()).hasNext()) {
      return (String)paramPGPPublicKey.next();
    }
    return "";
  }
  
  private PGPPublicKey a(InputStream paramInputStream)
    throws IOException, NoPublicKeyFoundException, PGPException
  {
    paramInputStream = createPGPPublicKeyRingCollection(paramInputStream);
    Object localObject1 = null;
    Object localObject2 = null;
    paramInputStream = paramInputStream.getKeyRings();
    while ((localObject2 == null) && (paramInputStream.hasNext()))
    {
      Object localObject3 = (localObject3 = (PGPPublicKeyRing)paramInputStream.next()).getPublicKeys();
      while ((localObject2 == null) && (((Iterator)localObject3).hasNext()))
      {
        PGPPublicKey localPGPPublicKey;
        if ((localPGPPublicKey = (PGPPublicKey)((Iterator)localObject3).next()).isEncryptionKey()) {
          if ((localPGPPublicKey.isRevoked()) && (!f))
          {
            a("The key {0} is revoked", KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()));
            localObject1 = new KeyIsRevokedException("The key with Key Id:" + KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()) + " [" + a(localPGPPublicKey) + "] is revoked. See PGPLib.setUseRevokedKeys for more information.");
          }
          else if ((b(localPGPPublicKey)) && (!e))
          {
            a("The key {0} is expired", KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()));
            localObject1 = new KeyIsExpiredException("The key with Key Id:" + KeyPairInformation.keyIdToHex(localPGPPublicKey.getKeyID()) + " [" + a(localPGPPublicKey) + "] has expired. See PGPLib.setUseExpiredKeys for more information.");
          }
          else if ((localObject2 == null) || (localPGPPublicKey.getBitStrength() > localObject2.getBitStrength()))
          {
            localObject2 = localPGPPublicKey;
          }
        }
      }
    }
    if (localObject2 == null)
    {
      if (localObject1 != null) {
        throw ((Throwable)localObject1);
      }
      throw new NoPublicKeyFoundException("Can't find encryption key in key ring.");
    }
    return localObject2;
  }
  
  private boolean b(PGPPublicKey paramPGPPublicKey)
    throws KeyIsExpiredException
  {
    if (paramPGPPublicKey == null) {
      return false;
    }
    if (e) {
      return false;
    }
    if (paramPGPPublicKey.getValidDays() <= 0) {
      return false;
    }
    Calendar localCalendar;
    (localCalendar = Calendar.getInstance()).setTime(paramPGPPublicKey.getCreationTime());
    localCalendar.add(5, paramPGPPublicKey.getValidDays());
    return localCalendar.getTime().before(new Date());
  }
  
  private void c(PGPPublicKey paramPGPPublicKey)
    throws KeyIsExpiredException
  {
    if (b(paramPGPPublicKey))
    {
      String str = "";
      Iterator localIterator;
      if ((localIterator = paramPGPPublicKey.getUserIDs()).hasNext()) {
        str = (String)localIterator.next();
      }
      a("The key {0} is expired", KeyPairInformation.keyId2Hex(paramPGPPublicKey.getKeyID()));
      throw new KeyIsExpiredException("The key with Id:" + KeyPairInformation.keyId2Hex(paramPGPPublicKey.getKeyID()) + " [" + str + "] has expired. See PGPLib.setUseExpiredKeys for more information.");
    }
  }
  
  private boolean d(PGPPublicKey paramPGPPublicKey)
    throws KeyIsRevokedException
  {
    if (paramPGPPublicKey == null) {
      return false;
    }
    if (f) {
      return false;
    }
    return paramPGPPublicKey.isRevoked();
  }
  
  private void e(PGPPublicKey paramPGPPublicKey)
    throws KeyIsRevokedException
  {
    if (d(paramPGPPublicKey))
    {
      String str = "";
      Iterator localIterator;
      if ((localIterator = paramPGPPublicKey.getUserIDs()).hasNext()) {
        str = (String)localIterator.next();
      }
      a("The key {0} is revoked", KeyPairInformation.keyId2Hex(paramPGPPublicKey.getKeyID()));
      throw new KeyIsRevokedException("The key with Id:" + paramPGPPublicKey.getKeyID() + " [" + str + "] is revoked. See PGPLib.setUseRevokedKeys for more information.");
    }
  }
  
  private static void a(OutputStream paramOutputStream, char paramChar, InputStream paramInputStream, String paramString, long paramLong, Date paramDate)
    throws IOException
  {
    PGPLiteralDataGenerator localPGPLiteralDataGenerator = null;
    OutputStream localOutputStream = null;
    try
    {
      localOutputStream = (localPGPLiteralDataGenerator = new PGPLiteralDataGenerator()).open(paramOutputStream, paramChar, paramString, paramLong, paramDate);
      paramOutputStream = new byte[1048576];
      while ((paramChar = paramInputStream.read(paramOutputStream)) > 0) {
        localOutputStream.write(paramOutputStream, 0, paramChar);
      }
      localPGPLiteralDataGenerator.close();
      IOUtil.closeStream(localOutputStream);
      IOUtil.closeStream(paramInputStream);
      return;
    }
    finally
    {
      if (localPGPLiteralDataGenerator != null) {
        localPGPLiteralDataGenerator.close();
      }
      IOUtil.closeStream(localOutputStream);
      IOUtil.closeStream(paramInputStream);
    }
  }
  
  private PGPSecretKey b(InputStream paramInputStream)
    throws NoPrivateKeyFoundException, IOException, PGPException
  {
    paramInputStream = createPGPSecretKeyRingCollection(paramInputStream);
    Object localObject1 = null;
    paramInputStream = paramInputStream.getKeyRings();
    while ((localObject1 == null) && (paramInputStream.hasNext()))
    {
      Object localObject2 = (localObject2 = (PGPSecretKeyRing)paramInputStream.next()).getSecretKeys();
      while ((localObject1 == null) && (((Iterator)localObject2).hasNext()))
      {
        PGPSecretKey localPGPSecretKey;
        if (((localPGPSecretKey = (PGPSecretKey)((Iterator)localObject2).next()).isSigningKey()) && (!localPGPSecretKey.isPrivateKeyEmpty())) {
          localObject1 = localPGPSecretKey;
        }
      }
    }
    if (localObject1 == null) {
      throw new NoPrivateKeyFoundException("Can't find signing key in key ring.");
    }
    c(localObject1.getPublicKey());
    e(localObject1.getPublicKey());
    return localObject1;
  }
  
  private PGPSecretKey c(KeyStore paramKeyStore, long paramLong)
    throws NoPrivateKeyFoundException, PGPException
  {
    if (((localObject2 = paramKeyStore.getKey(paramLong)) == null) || (!((KeyPairInformation)localObject2).hasPrivateKey())) {
      throw new NoPrivateKeyFoundException("No private key pair was found with Key Id: " + KeyPairInformation.keyId2Hex(paramLong));
    }
    paramLong = (paramLong = ((KeyPairInformation)localObject2).getRawPrivateKeyRing()).getSecretKeys();
    Object localObject1 = null;
    Object localObject2 = null;
    while ((localObject1 == null) && (paramLong.hasNext()))
    {
      PGPSecretKey localPGPSecretKey;
      if (((localPGPSecretKey = (PGPSecretKey)paramLong.next()).isSigningKey()) && (!localPGPSecretKey.isPrivateKeyEmpty()))
      {
        localObject2 = localPGPSecretKey;
        try
        {
          if ((hasKeyFlags(localObject3 = a.getPublicKey(localPGPSecretKey.getKeyID()), 2)) && (!b((PGPPublicKey)localObject3)) && (!d((PGPPublicKey)localObject3))) {
            localObject1 = localPGPSecretKey;
          }
        }
        catch (lw.bouncycastle.openpgp.PGPException localPGPException)
        {
          Object localObject3;
          throw IOUtil.newPGPException(localObject3 = localPGPException);
        }
      }
    }
    if ((localObject1 == null) && (localObject2 == null)) {
      throw new NoPrivateKeyFoundException("Can't find signing key in key ring.");
    }
    localObject1 = localObject2;
    c(localObject1.getPublicKey());
    e(localObject1.getPublicKey());
    return localObject1;
  }
  
  private void a(InputStream paramInputStream, String paramString1, PGPSecretKey paramPGPSecretKey, String paramString2, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, WrongPasswordException, IOException
  {
    if (!(paramOutputStream instanceof BufferedOutputStream)) {
      paramOutputStream = new BufferedOutputStream(paramOutputStream, 1048576);
    }
    if ((paramPGPSecretKey.getPublicKey() != null) && (paramPGPSecretKey.getPublicKey().getVersion() == 3))
    {
      a("Switching to version 3 signatures");
      signStreamVersion3(paramInputStream, paramString1, new ByteArrayInputStream(paramPGPSecretKey.getEncoded()), paramString2, paramOutputStream, paramBoolean);
    }
    if (paramBoolean)
    {
      a("Output is ASCII armored");
      paramOutputStream = paramOutputStream;
      paramOutputStream = new ArmoredOutputStream(paramOutputStream);
      a(paramOutputStream);
    }
    paramString2 = extractPrivateKey(paramPGPSecretKey, paramString2);
    int n = KeyStore.a(b);
    a("Signature with hash algorithm {0}", KeyStore.b(n));
    PGPSignatureGenerator localPGPSignatureGenerator = a.CreatePGPSignatureGenerator(paramPGPSecretKey.getPublicKey().getAlgorithm(), n);
    a.initSign(localPGPSignatureGenerator, 0, paramString2);
    if ((paramString2 = paramPGPSecretKey.getPublicKey().getUserIDs()).hasNext())
    {
      PGPSignatureSubpacketGenerator localPGPSignatureSubpacketGenerator = new PGPSignatureSubpacketGenerator();
      paramString2 = (String)paramString2.next();
      a("Signing for user Id {0}", paramString2);
      localPGPSignatureSubpacketGenerator.setSignerUserID(false, paramString2);
      localPGPSignatureGenerator.setHashedSubpackets(localPGPSignatureSubpacketGenerator.generate());
    }
    int i1 = h(paramPGPSecretKey.getPublicKey());
    paramString2 = new PGPCompressedDataGenerator(i1);
    if (i1 == 0)
    {
      a("No Compression");
      paramPGPSecretKey = new BCPGOutputStream(paramOutputStream);
    }
    else
    {
      a("Compression algorithm is {0}", KeyStore.a(i1));
      paramPGPSecretKey = new BCPGOutputStream(paramString2.open(paramOutputStream));
    }
    try
    {
      localPGPSignatureGenerator.generateOnePassVersion(false).encode(paramPGPSecretKey);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException1)
    {
      throw IOUtil.newPGPException(localObject = localPGPException1);
    }
    Object localObject = new DirectByteArrayOutputStream(1048576);
    byte[] arrayOfByte = new byte[1048576];
    int i2;
    while ((i2 = paramInputStream.read(arrayOfByte)) >= 0)
    {
      ((DirectByteArrayOutputStream)localObject).write(arrayOfByte, 0, i2);
      localPGPSignatureGenerator.update(arrayOfByte, 0, i2);
    }
    (paramString1 = (paramInputStream = new PGPLiteralDataGenerator()).open(paramPGPSecretKey, getContentType(), paramString1, ((DirectByteArrayOutputStream)localObject).size(), new Date())).write(((DirectByteArrayOutputStream)localObject).getArray(), 0, ((DirectByteArrayOutputStream)localObject).size());
    try
    {
      localPGPSignatureGenerator.generate().encode(paramPGPSecretKey);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException2)
    {
      throw IOUtil.newPGPException(paramInputStream = localPGPException2);
    }
    paramInputStream.close();
    paramString2.close();
    IOUtil.closeStream(paramString1);
    IOUtil.closeStream(paramPGPSecretKey);
    IOUtil.closeStream((OutputStream)localObject);
    paramOutputStream.flush();
    if (paramBoolean) {
      IOUtil.closeStream(paramOutputStream);
    }
  }
  
  private void a(InputStream paramInputStream1, String paramString1, InputStream paramInputStream2, String paramString2, InputStream[] paramArrayOfInputStream, OutputStream paramOutputStream, boolean paramBoolean)
    throws PGPException, IOException
  {
    if (paramBoolean)
    {
      a("Output is ASCII armored");
      paramOutputStream = paramOutputStream;
      paramOutputStream = new ArmoredOutputStream(paramOutputStream);
      a(paramOutputStream);
    }
    DirectByteArrayOutputStream localDirectByteArrayOutputStream = new DirectByteArrayOutputStream(1048576);
    BaseLib.pipeAll(paramInputStream1, localDirectByteArrayOutputStream);
    paramInputStream1 = a.CreatePGPEncryptedDataGenerator(1, false, IOUtil.getSecureRandom());
    PGPPublicKey[] arrayOfPGPPublicKey = new PGPPublicKey[paramArrayOfInputStream.length];
    for (int n = 0; n < paramArrayOfInputStream.length; n++)
    {
      arrayOfPGPPublicKey[n] = a(paramArrayOfInputStream[n]);
      paramInputStream1.addMethod(a.CreatePublicKeyKeyEncryptionMethodGenerator(arrayOfPGPPublicKey[n]));
      a("Ecrypting for key Id {0}", String.valueOf(arrayOfPGPPublicKey[n].getKeyID()));
    }
    PGPLiteralDataGenerator localPGPLiteralDataGenerator = new PGPLiteralDataGenerator(true);
    paramArrayOfInputStream = new DirectByteArrayOutputStream(1048576);
    paramString1 = localPGPLiteralDataGenerator.open(paramArrayOfInputStream, i, paramString1, localDirectByteArrayOutputStream.size(), new Date());
    localDirectByteArrayOutputStream.writeTo(paramString1);
    paramString1 = new DirectByteArrayOutputStream(1048576);
    detachedSignStream(new ByteArrayInputStream(localDirectByteArrayOutputStream.getArray(), 0, localDirectByteArrayOutputStream.size()), paramInputStream2, paramString2, paramString1, false);
    paramInputStream2 = paramString1.toByteArray();
    (paramString1 = new DirectByteArrayOutputStream(1048576)).write((byte)(paramInputStream2[0] | 0x1));
    paramString1.write(0);
    paramString1.write(paramInputStream2[1]);
    paramString1.write(paramInputStream2, 2, paramInputStream2.length - 2);
    try
    {
      paramInputStream1 = paramInputStream1.open(paramOutputStream, paramString1.size() + paramArrayOfInputStream.size());
      paramString1.writeTo(paramInputStream1);
      paramArrayOfInputStream.writeTo(paramInputStream1);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(paramInputStream1 = localPGPException);
    }
    paramOutputStream.flush();
    if (paramBoolean) {
      IOUtil.closeStream(paramOutputStream);
    }
  }
  
  private static InputStream a(KeyStore paramKeyStore, String paramString)
    throws PGPException
  {
    paramKeyStore = paramKeyStore.d(paramString);
    try
    {
      return new ByteArrayInputStream(paramKeyStore.getEncoded());
    }
    catch (IOException paramKeyStore)
    {
      throw new PGPException(paramKeyStore.getMessage(), paramKeyStore);
    }
  }
  
  private static InputStream d(KeyStore paramKeyStore, long paramLong)
    throws IOException, NoPublicKeyFoundException
  {
    paramKeyStore = paramKeyStore.b(paramLong);
    return new ByteArrayInputStream(paramKeyStore.getEncoded());
  }
  
  private static InputStream b(KeyStore paramKeyStore, String paramString)
    throws IOException, PGPException
  {
    paramKeyStore = paramKeyStore.findSecretKeyRing(paramString);
    return new ByteArrayInputStream(paramKeyStore.getEncoded());
  }
  
  private static InputStream e(KeyStore paramKeyStore, long paramLong)
    throws IOException, PGPException
  {
    try
    {
      paramKeyStore = b.getSecretKey(paramLong);
    }
    catch (lw.bouncycastle.openpgp.PGPException localPGPException)
    {
      throw IOUtil.newPGPException(paramKeyStore = localPGPException);
    }
    if (paramKeyStore != null) {
      return new ByteArrayInputStream(paramKeyStore.getEncoded());
    }
    throw new NoPrivateKeyFoundException("No private key was found with KeyId : " + paramLong);
  }
  
  private int f(PGPPublicKey paramPGPPublicKey)
  {
    int n = KeyStore.c(c);
    if (m) {
      return n;
    }
    int i1 = 0;
    Iterator localIterator = paramPGPPublicKey.getSignatures();
    while ((i1 == 0) && (localIterator.hasNext()))
    {
      Object localObject;
      if (((localObject = (PGPSignature)localIterator.next()).getHashedSubPackets() != null) && (((PGPSignature)localObject).getHashedSubPackets().getPreferredSymmetricAlgorithms() != null))
      {
        localObject = ((PGPSignature)localObject).getHashedSubPackets().getPreferredSymmetricAlgorithms();
        for (int i2 = 0; i2 < localObject.length; i2++)
        {
          i1 = localObject[i2];
          if (n == i1) {
            break;
          }
        }
      }
    }
    if (i1 == 0) {
      if (paramPGPPublicKey.getVersion() == 3) {
        i1 = 1;
      } else if (paramPGPPublicKey.getAlgorithm() == 18) {
        i1 = 9;
      } else {
        i1 = n;
      }
    }
    a("Cypher: {0}", KeyStore.c(i1));
    return i1;
  }
  
  private int g(PGPPublicKey paramPGPPublicKey)
  {
    int n = KeyStore.a(b);
    if (m) {
      return n;
    }
    int i1 = -1;
    Iterator localIterator = paramPGPPublicKey.getSignatures();
    while ((i1 == -1) && (localIterator.hasNext()))
    {
      Object localObject;
      if (((localObject = (PGPSignature)localIterator.next()).getHashedSubPackets() != null) && (((PGPSignature)localObject).getHashedSubPackets().getPreferredHashAlgorithms() != null))
      {
        localObject = ((PGPSignature)localObject).getHashedSubPackets().getPreferredHashAlgorithms();
        for (int i2 = 0; i2 < localObject.length; i2++)
        {
          i1 = localObject[i2];
          if (n == i1) {
            break;
          }
        }
      }
    }
    if (i1 == -1)
    {
      if (paramPGPPublicKey.getAlgorithm() == 19) {
        return 10;
      }
      i1 = n;
    }
    a("Hash: {0}", KeyStore.b(i1));
    return i1;
  }
  
  private int h(PGPPublicKey paramPGPPublicKey)
  {
    int n = KeyStore.b(d);
    if (m) {
      return n;
    }
    int i1 = -1;
    paramPGPPublicKey = paramPGPPublicKey.getSignatures();
    while ((i1 == -1) && (paramPGPPublicKey.hasNext()))
    {
      Object localObject;
      if (((localObject = (PGPSignature)paramPGPPublicKey.next()).getHashedSubPackets() != null) && (((PGPSignature)localObject).getHashedSubPackets().getPreferredCompressionAlgorithms() != null))
      {
        localObject = ((PGPSignature)localObject).getHashedSubPackets().getPreferredCompressionAlgorithms();
        for (int i2 = 0; i2 < localObject.length; i2++)
        {
          i1 = localObject[i2];
          if (n == i1) {
            break;
          }
        }
      }
    }
    if (i1 == -1) {
      i1 = n;
    }
    a("Compression: {0}", KeyStore.a(i1));
    return i1;
  }
  
  private static void a(BCPGOutputStream paramBCPGOutputStream)
  {
    Object localObject = BCPGOutputStream.class;
    byte[] arrayOfByte = { 80, 71, 80 };
    localObject = ((Class)localObject).getDeclaredMethods();
    for (int n = 0; n < localObject.length; n++)
    {
      Class[] arrayOfClass;
      if ((localObject[n].getName().endsWith("writePacket")) && ((arrayOfClass = localObject[n].getParameterTypes()).length == 3))
      {
        (localObject = localObject[n]).setAccessible(true);
        try
        {
          ((Method)localObject).invoke(paramBCPGOutputStream, new Object[] { new Integer(10), arrayOfByte, new Boolean(true) });
          return;
        }
        catch (InvocationTargetException localInvocationTargetException)
        {
          return;
        }
        catch (IllegalAccessException localIllegalAccessException)
        {
          return;
        }
      }
    }
    throw new Error("No such method: writeMarkerPacket");
  }
  
  private static File a(String[] paramArrayOfString)
    throws PGPException
  {
    File localFile;
    try
    {
      localFile = File.createTempFile("tmpTarBCPG", ".tar");
      Object localObject = new FileOutputStream(localFile);
      localObject = new TarOutputStream((OutputStream)localObject);
      for (int n = 0; n < paramArrayOfString.length; n++) {
        ((TarOutputStream)localObject).writeFileEntry(new TarEntry(new File(paramArrayOfString[n]), ""));
      }
      ((TarOutputStream)localObject).close();
    }
    catch (IOException localIOException)
    {
      throw new PGPException(localIOException.getMessage(), localIOException);
    }
    return localFile;
  }
  
  private void a(String paramString)
  {
    if (g.isLoggable(j)) {
      g.log(j, paramString);
    }
  }
  
  private void a(String paramString1, String paramString2)
  {
    if (g.isLoggable(j)) {
      g.log(j, MessageFormat.format(paramString1, new Object[] { paramString2 }));
    }
  }
  
  private static void a(String[] paramArrayOfString, String paramString)
  {
    for (int n = 0; n < paramArrayOfString.length; n++) {
      paramArrayOfString[n] = paramString;
    }
  }
  
  private static String b(String[] paramArrayOfString, String paramString)
  {
    int n;
    if ((n = paramArrayOfString.length) == 0) {
      return "";
    }
    StringBuffer localStringBuffer;
    (localStringBuffer = new StringBuffer()).append(paramArrayOfString[0]);
    for (int i1 = 1; i1 < n; i1++) {
      localStringBuffer.append(paramString).append(paramArrayOfString[i1]);
    }
    return localStringBuffer.toString();
  }
  
  public boolean isTrialVersion()
  {
    return true;
  }
  
  public boolean isPgp2Compatible()
  {
    return k;
  }
  
  public void setPgp2Compatible(boolean paramBoolean)
  {
    k = paramBoolean;
  }
  
  public boolean isExtractTarFiles()
  {
    return l;
  }
  
  public void setExtractTarFiles(boolean paramBoolean)
  {
    l = paramBoolean;
  }
  
  public boolean isOverrideKeyAlgorithmPreferences()
  {
    return m;
  }
  
  public void setOverrideKeyAlgorithmPreferences(boolean paramBoolean)
  {
    m = paramBoolean;
  }
  
  static
  {
    String str = "Your 30 day evaluation version of DidiSoft OpenPGP Libary for Java has expired.";
    try
    {
      Object localObject1;
      localObject4 = (localObject1 = (localObject1 = File.createTempFile("nb798t", ".tfp")).getAbsolutePath()).substring(0, ((String)localObject1).lastIndexOf(File.separator));
      i1 = (localObject1 = Calendar.getInstance()).get(2);
      int n = ((Calendar)localObject1).get(5);
      if ((localObject4 = new File((String)localObject4 + File.separator + "vafb7869c256be8c70.dat")).exists())
      {
        long l1 = ((File)localObject4).lastModified();
        long l2;
        if ((l2 = ((localDate = new Date()).getTime() - l1) / 86400000L) > 45L) {
          throw new RuntimeException(str);
        }
      }
      else
      {
        localFileOutputStream = null;
      }
    }
    catch (Exception localException2)
    {
      Object localObject4;
      Object localObject3;
      try
      {
        int i1;
        Date localDate;
        (localFileOutputStream = new FileOutputStream((File)localObject4)).write(i1 * 234 + localDate);
        localFileOutputStream.close();
      }
      finally
      {
        FileOutputStream localFileOutputStream;
        if (localFileOutputStream != null) {
          localFileOutputStream.close();
        }
      }
      try
      {
        localObject3 = (localObject3 = new SimpleDateFormat("MM/dd/yyyy")).parse("05/30/2017");
        localObject4 = new Date();
        if (((Date)localObject3).getTime() < ((Date)localObject4).getTime()) {
          throw new RuntimeException(str);
        }
        return;
      }
      catch (Exception localException2)
      {
        (localObject3 = localException2).printStackTrace();
      }
    }
  }
}
